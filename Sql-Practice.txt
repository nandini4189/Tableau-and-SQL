select *from tab;
create table student(sid number(4) primary key,
                    sname varchar2(10),
                    loc varchar2(10),
                    dob date,
                    age number(2) check(age>21),
                    cid number(2));
desc student;
commit;
alter table student add doj date;
create table course(cid number(3) primary key,
                    cname varchar2(10),
                    faculty_id number(2) 
                    constraint fk_course REFERENCES student(sid));
    alter table course add constraint pk_course primary key(cid);
desc course;
alter table course add constraint pk_course primary key(cname);
commit;
r table course drop constraint fk_faculty_id;
select *from course;
select *from student;
desc student;
create table course(cid number(3) primary key,
                    cname varchar2(10),
                    faculty_id number(2),
                    foreign key(cid) references student(sid));

select column_name,constraint_name from user_cons_columns where table_name='COURSE';


select ename,job,hiredate,deptno ,case when deptno=20 then 'ACCOUNTING'
                                when deptno=10 and job='MANAGER' then 'SALES'
                               else  ename end from emp; 



  select constraint_name,constraint_type from user_constraints where table_name='STUDENT';
 drop table course;
 
 create table course(cid number(4) primary key,
                        cname varchar2(10),
                        faculty_id number(2));
alter table student add foreign key(cid) references course(cid);
                        
                        
    desc student;   
    commit;
insert into student values(101,'umadevi','pune','10-sep-1991',24,10,'07-sep-2016');   

insert into course values(10,'MCA',1);
insert into course values(50,'EEE',5);

select *from course;
select *from student;
insert into student values(&sid,'&sname','&loc','&dob',&age,&cid,'&doj');
commit;
select s.sname,c.cname,s.sid,s.age,s.loc from student s inner join course c on (s.cid=c.cid);

select *from student;

create table emp2 as select *from emp;
create table x  as select *from emp;
select *from x;
truncate table emp2;
desc emp2;
alter table emp2 alter column sal varchar2(10);
alter table emp2 modify sal varchar2(10);
desc emp2;
insert into emp2 select *from x;
select *from emp2;
insert into emp2 values(2221,'UMA','CLERK',6653,'12-SEP-22','S120',120,10);
select s.sname,c.cname from student s,course c where s.cid=c.cid and c.cname in('MCA','ECE')order by c.cname;

roll back;
select *from emp;
select CONVERT(varchar2(9),getdate()) as result;
select CONVERT(VARCHAR(10),GETDATE(),3)"RESULTL";
COMMIT;
....................................................


select substr(ename,1,3) from emp;
select initcap(substr(ename,1,6)) "employee",length(ename) from emp where length(ename)<>6 and deptno=20;
select initcap(lower(substr(ename,1,4))) "employee",length(ename)from emp where deptno=30;

select substr('ksheerasagare jaya praveen',1,instr('ksheerasagare jaya praveen',' ')-1)
"first name" , substr('ksheerasagare jaya praveen',instr('ksheerasagare jaya praveen',' ',1,2)+1) 
"last name" from dual;


select substr('ksheerasagare jaya praveen',1,instr('ksheerasagare jaya praveen',' ',1,1))
"first name" from dual;

select substr('ksheerasagare jaya praveen',instr('ksheerasagare jaya praveen',' ',1,2))
"last name" from dual;

select (instr('ksheerasagare jaya praveen',' ',1,2)-instr('ksheerasagare jaya praveen',' ',1,1)) from dual;


select substr('siva rama krishna',1,instr('siva rama krishna',' ',1,1)-1) "first name" ,
substr('siva rama krishna',instr('siva rama krishna',' ',1,1),
(instr('siva rama krishna',' ',1,2)
-instr('siva rama krishna',' ',1,1))) "middle name",
substr('siva rama krishna',instr('siva rama krishna',' ',1,2)+1)"last name" from dual;
commit;


select substr('lavanya sri janu',instr('lavanya sri janu',' ',1,1),instr('lavanya sri janu',' ',1,2)-(instr('lavanya sri janu',' ',1,1))) "middle name" from dual


select substr('siva rama krishna',instr('siva rama krishna',' ',1,1),
(instr('siva rama krishna',' ',1,2)
-instr('siva rama krishna',' ',1,1))) "middle name" from dual;

select substr('siva rama krishna',instr('siva rama krishna',' ',1,2)+1) "last name" from dual;

select ename||' '||q'(designation'S)'||' '||initcap(job)||' '||'joining date is'||' '||hiredate from emp;

select to_char(sysdate,'yy/mon/dd') from dual;
select to_char(sysdate,'yyy/month/dd') from dual;
select to_char(sysdate,'yy/mm/dd') from dual;
select last_day(sysdate,'wed') from dual;
select now();

select deptno, decode(deptno,10,'ACCOUNTING',
                    20,'SALES',
                    30,'REASERCH')"result"  group by deptno from emp;
select round(sysdate,yyyy)from dual;

select sysdate from dual;
select to_char(sysdate,'month') from dual;
select to_char(sysdate,'dd') from dual;
select last_day(sysdate)+1 from dual;
select last_day(sysdate)-2 from dual;
select last_day(hiredate)-2 from emp;
select next_day(hiredate,'day') from emp;
select round(to_date('01-jul-14'),'year') as new_year from dual;
select (sysdate+5/1440) from dual;
select sysdate + (5/1440) as five_mintues_from_now
from dual

commit;

select trunc(sysdate,'day') from dual;

select trunc(sysdate,'month') from dual;
select round(sysdate,'year') from dual;
select upper(ename) from emp where ename='SMITH' and job='CLERK';
select deptno,sum(sal) as total_sal from emp group by deptno order by deptno;
select sum(sal) from emp group by deptno;

SELECT * FROM EMP WHERE DEPTNO!=ALL(10,NULL,20);

SELECT * FROM EMP WHERE DEPTNO=ANY(10,NULL,20);
select deptno,sum (sal)"tot_sal" from emp group by deptno;
select sum(sal+nvl(comm,0)) as tot_sal from emp where deptno=20;
select deptno,sum(sal) from emp group by deptno;
select *from emp;
select sum(sal) from emp where deptno=20;

\select sum(sal+nvl(comm,0)) "totsal" from emp group by deptno;

45.select deptno,max(sal) from emp group by deptno;

46.select job,sum(sal) "salary" from emp group by job;

47.select job,min(sal) from emp group by job;

48.select deptno,count(*) from emp group by deptno having count(*)>5;

49.select job,sum(sal) "totsal" from emp group by job having sum(sal)>4000; 

50.select job,count(*) "tot employees" from emp group by job having count(*)>3;

51.select ename,sal from emp where sal=(select max(sal) from emp);

52.select empno,ename,job,sal from emp where job='CLERK' and sal=(select max(sal) from emp where job='CLERK');

53.select ename,job,sal from emp where job='SALESMAN' and sal>(select max(sal) from emp where job='CLERK');

54. select ename,job,sal from emp where job='CLERK' and sal>(select min(sal)from emp where job='SALESMAN');
 
 select *from emp where sal in(select distinct top 5 sal from emp )order by sal desc;
 select *from emp e inner join dept d on e.deptno=d.deptno and comm>12/100;
 
  select *from emp e inner join dept d on e.deptno=d.deptno and comm>12/100 and e.sal<>1600;

create table num(no number(3),doj date);
desc num;
insert into num values(&no,'&doj');
select *from num;


***************doubt*******.................
select case   when length(no)=1 then concat('0',no)
              when length(no)=2 then concat(no,'')
               else null end as value from num order by no
               *********************************

               
select sal,deptno,job,
                case when deptno=10 and job='MANAGER' then  sal+200
                 when deptno=10 then sal+100
                    else null end as value  from emp;


55.select ename from emp where sal > ANY(select sal from emp where ename in('JONES','SCOTT'));

56.select job from emp e where sal=(select max(sal) from emp e , dept d where e.deptno=d.deptno)
 
57.select ename from emp e where sal=(select max(sal) from emp where e.job=job)
                    (or)
   select ename from emp where (job,sal) 
            in(select job,max(sal) from emp group by job)

select *from emp;
58.select ename from emp where deptno=(select deptno from dept where dname='ACCOUNTING');
                        (or)     
    select e.ename,d.dname from emp e inner join dept d on(e.deptno=d.deptno) and d.dname='ACCOUNTING'

59.select ename from emp where deptno=(select deptno from dept where loc='CHICAGO')
                        (or)
    select e.ename,d.dname,loc from emp e,dept d where e.deptno=d.deptno and loc='CHICAGO';

60.select job,sum(sal) from emp group by job having sum(sal)>(select max(sal) from emp where job='MANAGER')

61.select ename ,deptno,sal from emp where deptno=10 and sal> ANY(select deptno from dept where deptno in(20,30)) 

62.select ename from emp where deptno=10 and sal> ALL(select sal from emp where deptno in(20,30))

63.select upper(ename)from emp;

64.select lower(ename) from emp;

65.select initcap(ename) from emp;

66.select length('umadevi') from dual;

67.select length(ename)from emp

68.select ename||empno from emp OR select concat(ename,empno) from emp

69.



    select translate('umadevi','umadevi','ramakrish') from dual;

select translate('umadevi is a good girl','umadevi','ramkris') from dual;

select lpad(' ',rownum+1,'*')||ename as employees_name from emp


select lpad(' ',rownum+1,'*')||job from emp

70.select instr('computer maintenance corporation','a',1,2) no from dual;

71.select translate('Alliens','a','B') from dual;

72.select empno,ename,hiredate,sal,deptno, REPLACE(job,'MANAGER','BOSS') job from emp

73.select empno,ename,decode(deptno,10,'ACCOUNTING',
                                         20,'SALES',
                                        30,'RESEARCH') deptno from emp;
                                        
74.select round(sysdate-to_date('28-feb-1991')) "age in days" from dual; 

      
75.select round(months_between(sysdate,'28-feb-1991')) "months" from dual;

76.select to_char('15th August Friday Nienteen Nienty Seven') "current date"  from dual;

79.select next_day(sysdate,'saturday') from dual;

80.select current_date from dual; OR select sysdate from dual;
commit:


select *from emp where exists(select 15 from emp);
select *from emp where exists(select 1 from emp where 2=2)
select *from emp where exists(select *from dept)
select *from emp where not exists(select *from dept where 1=2)
commit;


SELECT sal FROM (
    SELECT sal, row_number() OVER (order by sal desc) AS rn FROM emp
)
WHERE rn = 2


select ename,sal from emp e where 1-1=(select count(distinct sal) from emp e1 where e1.sal>e.sal);
select ename,empno,deptno,sal from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>=e.sal) 

81.select add_months(sysdate,-3) from dual;

82.select deptno from emp where deptno=10 
intersect
select deptno from dept where deptno=20;

83.select deptno from emp where deptno=10
union 
select deptno from emp where deptno=20        

select *from emp where deptno=10 and job in(select job from emp where deptno=20)

select *from (select *from (select *from emp))

84.select distinct(job) from emp where deptno=10;

select deptno,dname from dept where deptno not in(select distinct(deptno) from emp)

select *from emp where deptno not in(select job from emp where job='MANAGER')

85.select empno,job,ename from emp where empno not in(select mgr from emp where mgr is not null) 

86.select *from emp e,dept d,salgrade s where e.deptno=d.deptno and d.dname='SALES' 
and e.sal between losal and hisal and s.grade=3

select *from emp;

select ename,sal,job,empno from emp where empno not in(select nvl(mgr,0) from emp)

87.select *from emp where job<>'MANAGER';
                    
select empno,ename,sal from emp where sal>ANY(select sal from emp where deptno=10)order by ename;
select sal from emp where deptno=10;
select *from emp where sal>(select max(sal) from emp where deptno=10)
select empno,ename,job,sal from emp where deptno=30 and exists(select count(*) 
from emp where deptno=30 
and job='ANALYST' having count(*)>=3);

88. select ename from emp where length(ename)>4

89. select dname,loc from dept where dname like'S%' or loc like'%K'

90. select e.ename,m.ename from emp e  inner join emp m on(m.empno=e.mgr) where m.ename='JONES';

92.select *from emp e inner join dept d on e.deptno=d.deptno

91.select ename,sal from emp where sal*1.20>3000 
                (OR)
    select *from emp where empno in(select empno from emp where (sal+sal*20/100)>3000)

93.select ename,deptno from emp where deptno in(select deptno from dept where dname='SALES')

94.select e.ename,d.dname,sal,comm,loc from emp e inner join dept d on(e.deptno=d.deptno) where e.sal
between 2000 and 5000 and loc='CHICAGO';

95.select * from emp e,emp m where e.mgr=m.empno and e.sal>m.sal

    select *from emp e where e.sal>(select m.sal from emp m where m.empno=e.mgr)

96.select distinct m.ename from emp e,emp m where e.mgr=m.empno and e.deptno=m.deptno

 select *from emp e where deptno=(select m.deptno from emp m where e.mgr=m.empno)

select  * from emp 
cross join dept


select *from emp order by comm;
select *from emp order by comm desc
select *from emp order by empno 
 select ename,select deptno,select sal,select hiredate from emp;
 select *from emp where empno not in(select nvl(mgr,0) from emp)
 select *from emp where empno not in(select distinct mgr from emp where mgr is not null)
 
 select *from emp where rownum<=5;
 
 select *from emp 
 minus
 select *from emp where rownum<=(select count(*)-(9) from emp);
 minus
select * from  emp
 minus
 select * from emp where rownum<=(select count(*)-(5) from emp);



 
 ***************First five records*************
  select *from emp where rownum<=(select count(*)-(9) from emp)




  
  *********** last five records*********
 select * from  emp
 minus
 select * from emp where rownum<=(select count(*)-(5) from emp);


 *************************************************
 
.......................department wise maximum of sum of salries...............

select deptno,sum(sal) from emp group by deptno having sum(sal)=
(select max(sum(sal)) from emp group by deptno)




............................

select * from emp
where  exists (select * from dept);
select * from emp 
where exists (select * from emp where 3=3);

select * from emp e
where exists(select * from emp e1 where e1.mgr=e.empno);

select * from emp e
where exists (select * from dept d where d.deptno=e.deptno);



*** *********display 3rd highest salary*****

select * from emp e where 3=(select count(distinct sal) from emp e1 where e1.sal>=e.sal);

select *from emp e where 2=(select count(distinct sal)from emp e1 where e1.sal>=e.sal);
...............................................................




>>>>>>>>>>> >>>>>>   display managers names  >>>>>>>>> 

select e.ename "managers_name" from emp e where exists(select *from emp e1 where e1.mgr=e.empno) 
            OR
select distinct m.ename from emp e, emp m where e.mgr=m.empno
            OR
select ename from emp where empno in(select mgr from emp)   



*****************************************************************************************

************display the details of employees who are getting highest sal of "BLAKE"  ***********  
     
select *from emp where sal>(select sal from emp where ename='BLAKE')




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
........... how to get second record.........

select *from emp where rownum<3 
minus
select *from emp where rownum<2



...........................................    
    
    select *from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>=e.sal)
    
      select REGEXP_SUBSTR('test1 test2 test3', '[^ ]+', 1, 2) from dual;
select max(sal) from(select sal from emp);
select max(sal) from(select sal from emp)

select substr(ltrim('pittu uma devi',substr('pittu uma devi',1,5)),2,3) from dual;
 
     
select empno,avg(sal),count(comm) from dept join emp using(deptno) group by empno;

select e.ename, d.dname,loc from emp e join dept d on d.deptno=20

select ename,hiredate from emp where to_char(hiredate,'yyyy')=1982;
select ename,to_date(hiredate,'DD-MM-YY') from emp;

commit;

select sal,ltrim(ename,'B') from emp where empno=7698;

select *from tab;
drop table grade_type;
 SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = "INSTRUCTOR";


 
+++++++++ doubt+++++++++++++select ename,empno from emp where decode (deptno, 20,'ACCOUNTING',
                                                30,'SALES',
                                                40,'RESEARCH','OPERATIONS');



                                                
*****************2nd exam questions and answers::::::::::::::



1. Write a SELECT statement that lists the last names of students living in either zip code 10048, 11102, or 11209.

select last_name,zip  from student where zip in(10048,11102,11209)        or

select last_name ,zip from student where zip=10048 or zip=11102 or zip=11209
                                                
2. Write a SELECT statement that lists the first and last names of instructors with the letter i 
(either uppercase or lowercase) in their last name, living in zip code 10025.
   
   select first_name||' '||last_name from instructor where upper(last_name) like '%I%' or lower(last_name) like '%i%' and zip=10025
   
   select first_name||' '||last_name from instructor where lower(last_name) like'%i%' and zip=10025
    
3. Write a SELECT statement that lists descriptions of courses for which there are prerequisites 
and that cost less than 1100.
 
    select description,cost,prerequisite from course where prerequisite is not null and cost < 1100
 
 4. Show the salutation, first name, and last name of students with the last name Grant. 
Order the result by salutation in descending order and by first name in ascending order.

    select salutation,first_name,last_name from student where last_name= 'Grant' order by salutation desc,first_name                                       
                                                
 5. Write a SQL statement to retrieve students who have a last name with the lowercase letter o 
occurring three or more times. 

   doubt ///////////////select student_id,last_name from student where instr(last_name,'o',1,3)> 2;
                                                
6.     Using functions in the SELECT list and WHERE and ORDER BY clauses, write a SELECT statement that 
returns course numbers and course descriptions from the COURSE table and looks like the following result set. 
Use the SQL Developer Run Script icon to display the result in fixed-width format.
Description
204.......Intro to SQL
130.......Intro to Unix
25........Intro to Programming
230.......Intro to the Internet
120.......Intro to Java Programming
240.......Intro to the BASIC Language
20........Intro to Information Systems
                                         
    select rpad(course_no,10,'.')||' '||description from course                                       
                                                
 7.  List the last names, first names, and phone numbers of students who do not have phone numbers. 
Display 212-555-1212 for the phone number.

  select last_name,first_name,phone "mobile",nvl2(phone,'0','212-555-1212') "contact_number"  from student                                         

    select last_name,first_name,phone "mobile",nvl(phone,'212-555-1212') "contact_number"  from student                                            
                                                
 8. Write a SELECT statement that determines the total number of students enrolled. 
Count each student only once, no matter how many courses the student is enrolled in.
                                               
         select count(distinct student_id) from enrollment                                        
                                                
9. Determine the average cost for all courses. If the course cost contains a null value, substitute the value 0.
          
          select avg(nvl(cost,0)) from course                
          
10. Write a SELECT statement that determines the date of the most recent enrollment.     

    select max(enroll_date) from enrollment
    
11. Show a list of prerequisites and count how many times each appears in the COURSE table. 
Order the result by the PREREQUISITE column.

    select prerequisite,count(*) from course group by prerequisite order by prerequisite

12. Show all the different companies for which students work. Display only companies in 
which more than four students are employed.

   select employer,count(*) from student group by employer having count(*)>4;

13. Select the course description, section number, and location for sections meeting in location L211.
    
    select c.description,s.section_no,s.location from course c inner join section s on c.course_no=s.course_no and location='L211';

14. Show the course description, section number, starting date and time of the courses Joseph German is taking.

 select c.description,s.section_id,s.start_date_time from course c,section s,enrollment e,student st where
    c.course_no=s.course_no and
    s.section_id=e.section_id and
    st.student_id=e.student_id and 
    st.first_name='Joseph' and st.last_name='German'  

15 .Using a subquery construct, determine which sections the student Henry Master is enrolled in.

    select student_id from enrollment where student_id =
    (select student_id from student where first_name='Joseph' and last_name='German')




select deptno,avg(sal) "no of dept"
from emp
where ename='SMITH'
group by deptno
having avg(sal)>10000
order by ename
commit


select *from dept

************************CASE & DECODE******************

SELECT ename, empno,
 (CASE deptno
 WHEN 10 THEN 'Accounting'
 WHEN 20 THEN 'Research'
 WHEN 30 THEN 'Sales'
 WHEN 40 THEN 'Operations'
 ELSE 'Unknown'
  END) department
FROM emp
ORDER BY ename;

select job,sal,deptno,(case when lower(ename)='allen' then 'UMA'
                                    when lower(ename)='blake' then 'SHAN'
                                    when lower(ename)='james' then 'KRISH'
                                    else 'Unknown' end) employee from emp;


select ename,sal,deptno,decode(deptno,20,'ACCOUNTING',
                                30,'SALES',
                                40,'RESEARCH',
                                deptno)department_name from emp;


select ename,job,deptno,decode(job,'CLERK','UMA',
                                    'MANAGER','KRISH',
                                    'SHAN')job_details from emp;

select *from emp where decode(deptno,10,'ACCOUNTING',
                                     20,'SALES',
                                     deptno)


commit;


************************ ROW ID, ROWNUM**************************


select rowid,rownum from dual;

select m.ename,e.mgr,count(*) "no of employees" from emp e inner join emp m on (e.mgr=m.empno) group by e.mgr,m.ename; 


SELECT uid, user FROM dual;
select e.*,rownum,rowid from emp e order by rownum

select e.*,rownum from
(select * from emp  order by sal desc) e


select e.*,rownum from
(select * from emp  order by sal desc) e
where rownum<=2;

select * from 
(select e.*,rownum rn from
(select * from emp  order by sal desc) e)
where rn=2;

select *from(select e.*,rownum rn from(select *from emp order by sal desc) e) where rn=2;

select min(sal) from (select * from (select sal from emp order by sal desc) where   rownum <=2);

select * from emp where sal=(
 select min(sal) from (select * from (select sal from emp order by sal desc) where   rownum <=2));


select *from emp where sal=
(select min(sal) from
(select *from
(select sal from emp order by sal desc) 
where rownum <=2))

select min(sal),max(sal) from emp where sal<
(select max(sal) from emp)
and
sal>(select min(sal) from emp)

select *from emp
minus
select *from emp where rownum <=(select count(*)-5 from emp)

select deptno,sum(sal) from emp group by deptno having sum(sal)=(select max(sum(sal))from  emp group by deptno);

select max(sum(sal)) from emp group by sal;


select *from emp e where 2=(select count(distinct sal) from emp e1 where e1.sal>=e.sal)


select *from emp where sal=
(select min(sal) from
(select *from 
(select sal from emp order by sal desc) 
where rownum <=2))

select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))

select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))


select rowid,e.* from emp e;


select ename,empno,mgr,job 
    from emp 
    start with job='PRESIDENT' connect by ;
    
    select ename, empno, mgr, job 
    from emp 
    start with job ='PRESIDENT' 
    connect by prior empno = mgr;
    
    
sql-ex.ru


select*from emp where sal=(select min(sal) from(select *from emp e where 2=(select count(distinct sal)from emp e1 where e1.sal>=e.sal)));

select ename,job,sal,mgr from emp connect by prior empno=mgr

select ename, empno, mgr, job 
    from emp 
    connect by prior empno = mgr;

select ename, empno, mgr, job 
    from emp 
    start with job ='PRESIDENT' 
    connect by prior empno = mgr;
    
select ename,sal,job from emp start with sal=3000 connect by prior empno=mgr;

select ename,job,sal from emp start with sal=(select max(sal) from emp) connect by prior empno=mgr
select *from tab;
select *from tab;

select *from num
select no,rowid from num 
 
 
select ename, empno, mgr, job, sal 
    from emp 
    start with sal = (select max(sal) from emp 
                               where deptno = (select deptno from dept 
                                                           where dname ='ACCOUNTING' )) 
   connect by prior empno = mgr;
   
   
commit;

   
   select ename name, connect_by_root(ename) boss 
     from emp 
     start with empno = 7839 
     connect by prior empno = mgr;
     
     
     
   *********************** INLINE VIEWS*************************
   
     
     select ename,sal,job from (select count(*) from emp ) e;
   
   select ename,job,sal,deptno from(
select * from emp where deptno=20) e;
                            
select *from(select max(sal) from emp group by deptno order by deptno) e; 

select ename,deptno
from(select *from emp where sal in(select max(sal) from emp group by deptno)order by deptno)


    select  distinct ename,sal from emp e,(select deptno,count(*) from emp e group by deptno order by deptno) 
    d,(select grade,losal,hisal from salgrade) s
    where e.deptno=d.deptno and e.sal between 3000 and 5000
    order by sal;



select distinct job,e.deptno from emp e,(select dname,deptno from dept) d where e.deptno=d.deptno

select ename,job,e.deptno from emp e,lateral(select dname,deptno from dept where e.deptno=d.deptno) d 

select st.student_id,first_name,last_name from student st ,
(select section_id,location from section) s,
(select section_id,enroll_date,student_id from enrollment) e
    where s.section_id=e.section_id and
    st.student_id=e.student_id


update (select sal from emp inne join dept using(deptno) where dname='SALES') set sal=sal+100
select *from emp

select ename from emp(select max(sal) from emp) e

CREATE TABLE STUDENT
 (STUDENT_ID NUMBER(8,0) 
 ,SALUTATION VARCHAR2(5)
 ,FIRST_NAME VARCHAR2(25)
 ,LAST_NAME VARCHAR2(25) 
 ,STREET_ADDRESS VARCHAR2(50)
 ,ZIP VARCHAR2(5) 
 ,PHONE VARCHAR2(15)
 ,EMPLOYER VARCHAR2(50)
 ,REGISTRATION_DATE DATE 
 ,CREATED_BY VARCHAR2(30) 
 ,CREATED_DATE DATE 
 ,MODIFIED_BY VARCHAR2(30) 
 ,MODIFIED_DATE DATE 
 )
/

COMMENT ON TABLE STUDENT IS 'Profile information for a student.'
/

COMMENT ON COLUMN STUDENT.STUDENT_ID IS 'The unique ID for a student.'
/

COMMENT ON COLUMN STUDENT.SALUTATION IS 'The student''s title (Ms., Mr., Dr., etc.).'
/

COMMENT ON COLUMN STUDENT.FIRST_NAME IS 'This student''s first name.'
/

COMMENT ON COLUMN STUDENT.LAST_NAME IS 'This student''s last name.'
/

COMMENT ON COLUMN STUDENT.STREET_ADDRESS IS 'The student''s street address.'
/

COMMENT ON COLUMN STUDENT.ZIP IS 'The postal zip code for this student.'
/

COMMENT ON COLUMN STUDENT.PHONE IS 'The phone number for this student including area code.'
/

COMMENT ON COLUMN STUDENT.EMPLOYER IS 'The name of the company where this student is employed.'
/

COMMENT ON COLUMN STUDENT.REGISTRATION_DATE IS 'The date this student registered in the program.'
/

COMMENT ON COLUMN STUDENT.CREATED_BY IS 'Audit column - indicates user who inserted data.'
/

COMMENT ON COLUMN STUDENT.CREATED_DATE IS 'Audit column - indicates date of insert.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_BY IS 'Audit column - indicates who made last update.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_DATE IS 'Audit column - date of last update.'
/CREATE TABLE STUDENT
 (STUDENT_ID NUMBER(8,0) 
 ,SALUTATION VARCHAR2(5)
 ,FIRST_NAME VARCHAR2(25)
 ,LAST_NAME VARCHAR2(25) 
 ,STREET_ADDRESS VARCHAR2(50)
 ,ZIP VARCHAR2(5) 
 ,PHONE VARCHAR2(15)
 ,EMPLOYER VARCHAR2(50)
 ,REGISTRATION_DATE DATE 
 ,CREATED_BY VARCHAR2(30) 
 ,CREATED_DATE DATE 
 ,MODIFIED_BY VARCHAR2(30) 
 ,MODIFIED_DATE DATE 
 )
/

COMMENT ON TABLE STUDENT IS 'Profile information for a student.'
/

COMMENT ON COLUMN STUDENT.STUDENT_ID IS 'The unique ID for a student.'
/

COMMENT ON COLUMN STUDENT.SALUTATION IS 'The student''s title (Ms., Mr., Dr., etc.).'
/

COMMENT ON COLUMN STUDENT.FIRST_NAME IS 'This student''s first name.'
/

COMMENT ON COLUMN STUDENT.LAST_NAME IS 'This student''s last name.'
/

COMMENT ON COLUMN STUDENT.STREET_ADDRESS IS 'The student''s street address.'
/

COMMENT ON COLUMN STUDENT.ZIP IS 'The postal zip code for this student.'
/

COMMENT ON COLUMN STUDENT.PHONE IS 'The phone number for this student including area code.'
/

COMMENT ON COLUMN STUDENT.EMPLOYER IS 'The name of the company where this student is employed.'
/

COMMENT ON COLUMN STUDENT.REGISTRATION_DATE IS 'The date this student registered in the program.'
/

COMMENT ON COLUMN STUDENT.CREATED_BY IS 'Audit column - indicates user who inserted data.'
/

COMMENT ON COLUMN STUDENT.CREATED_DATE IS 'Audit column - indicates date of insert.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_BY IS 'Audit column - indicates who made last update.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_DATE IS 'Audit column - date of last update.'
/

select *from student

show user

select *from tab;


16.SELECT e.student_id, s.course_no,
TO_CHAR(e.enroll_date,'MM/DD/YYYY HH:MI PM')enroll,
e.section_id
FROM enrollment e JOIN section s
ON (e.section_id = s.section_id)
WHERE s.course_no = 20
AND e.enroll_date >= TO_DATE('01/30/2007','MM/DD/YYYY')
AND e.enroll_date < TO_DATE('01/31/2007','MM/DD/YYYY')  

17.
SELECT c.description, s.section_no, c.cost, s.capacity
FROM course c, section s
WHERE c.course_no = s.course_no
AND s.capacity <=
(SELECT AVG(capacity)
FROM section)
AND c.cost =	
(SELECT MIN(cost)
FROM course)

18.
SELECT course_no, SUM(capacity)
FROM section
GROUP BY course_no
HAVING SUM(capacity) <
(SELECT round(AVG(capacity))
FROM section)

19.
SELECT ROWNUM id, course_no, num_enrolled
FROM (SELECT COUNT(*) num_enrolled, s.course_no
FROM enrollment e, section s
WHERE e.section_id = s.section_id
GROUP BY s.course_no
ORDER BY 1 DESC)
WHERE ROWNUM <= 5

select rownum id,course_no from
(select count(*),s.course_no 
from enrollment e,section s 
where e.section_id=s.section_id 
group by s.course_no
order by 1 desc)where rownum<=5

20.
SELECT section_id, TO_CHAR(start_date_time, 'HH24:MI')
  FROM section
 WHERE TO_CHAR(start_date_time, 'HH24:MI') ='10:30'





select to_number('123') from dual;
select to_number('123.45','999.00') from dual;
select to_number('1.234','9D999') from dual;

select to_number('$17 218,00','L999G999D00',' NLS_NUMERIC_CHARACTERS='', ''') from dual;
select to_date('08-MAR-1991') from dual;
select to_date('08-03-91','DD-MM-YY') from dual;
select to_date('08-03-91','DD-MON-YY') from dual;


 select min(sal) from emp where sal>(select min(sal) from emp);


************** 2ND LOWEST SALARY*****************

select * from emp where sal=(
 select max(sal) from (select * from (select sal from emp order by sal) where   rownum <=2));


**************************************************************************************************

 ***************** 2ND HIGHEST SALARY&***********************


    select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))

***************************************************************************************

select min(sal),max(sal) from emp where sal<(select max(sal) from emp) and 
                                        sal > (select min(sal) from emp)
                                        
                                        
                                        
SELECT Sal,Ename
FROM
  (
   SELECT Sal,Ename,ROW_NUMBER() OVER(ORDER BY Sal) As RowNum
   FROM EMP
   ) As A
WHERE A.RowNum IN (2,3)                                        

select *from user_tables 

select count(empno) from user_tab_columns where table name='emp'
SELECT DNAME, DEPTNO FROM DEPT WHERE EXISTS (SELECT * FROM EMP WHERE DEPT.DEPTNO = EMP.DEPTNO) 

select * from emp where rownum < 6 order by sal asc

select *from num;

select ename from emp where to_char(hiredate,'fmMONTH')='DECEMBER'



-----------------------------------------------------------------------------



4.select *from emp order by deptno asc,job desc 

5.select distinct job from emp order by job desc

6.select empno from emp where empno in(select mgr from emp)

7.select *from emp where hiredate<('01-jan-1981');

8.select empno,ename,sal,sal*12 "annualsal" from emp order by sal*12 asc

 9.select empno,ename,job,hiredate,round(months_between(sysdate,hiredate)) "exp" from emp where empno in(select mgr from emp)

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/30) "months of exp" from emp 

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/365) "year of exp" from emp where empno in(select mgr from emp)

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/12) "days of exp" from emp where empno in(select mgr from emp)



**********************************************************************************************************************************************

                                        DUMMY TABLE JOINS

select *from num
select *from num

alter table num add (loc varchar2(20),sal number(5))


alter table num modify sal varchar2(10desc num
desc num

insert into num values(15,'18-jun-2010','sruthi','bang','t6000',7000)

alter table num modify sal number(5)

select sal from num


create table hike(id number(3),sal number(5))

alter table hike modify name varchar2(20)

select *from num

desc hike
update num set sal='b5000' where no=12

select n.name,h.sal,n.sal from num n,hike h where n.sal=h.sal

insert into num values(13,'shan')
select n.sal,h.name from num n inner join hike h  on(h.sal=n.sal)

select n.sal,s.salary from num n full join num s on(n.sal=to_char(s.salary)) 

select n.salary,h.sal,h.name  from num n left join hike h on(n.salary=h.sal)

select n.salary,h.sal,h.name  from num n right join hike h on(n.salary=h.sal)

select n.salary,h.sal,h.name  from num n full join hike h on(n.salary=h.sal)

select *from num n cross join hike



select *from num
select *from hike

desc hike
alter table num add salary number(5)
commit



*******************************************************************************************************************************************************



select *from tab;

select *from employees
select *from departments
select *from locations

select e.first_name,e.last_name,e.department_id,d.department_name from employees e inner join departments d on(e.department_id=d.department_id)

select e.first_name,e.last_name,e.department_id,l.city,l.state_province,l.location_id
from employees e inner join departments d on(e.department_id=d.department_id) inner join locations l on(d.location_id=l.location_id)


select e.first_name,e.last_name,e.salary,j.job_id 
from employees e inner join jobs j on e.salary between j.min_salary and j.max_salary


SELECT E.first_name, E.last_name, E.salary, J.grade_level
 FROM employees E 
   JOIN job_grades J
     ON E.salary BETWEEN J.lowest_sal AND J.highest_sal;

select e.first_name,e.last_name,d.department_id,d.department_name from employees e inner join departments d 
on(e.department_id=d.department_id) where e.department_id in(40,80)


select l.city,l.state_province,d.department_id,e.first_name,e.last_name from employees e inner join departments d
on(e.department_id=d.department_id) join locations l using(location_id) where e.first_name like'%l%'


select e.first_name,e.last_name,d.department_id,d.department_name from employees e right join departments d on(e.department_id=d.department_id)

select e.first_name,e.last_name,e.salary,s.salary 
from employees e join employees s on(e.salary < s.salary) and s.employee_id=182

commit

select e.first_name from employees e natural join departments 


desc country
create table country(cname varchar2(10),gender varchar2(2))
                                                             
insert into country values('&cname','&gender')


select cname,sum(decode(gender,'m',1,0)) male,
            sum(decode(gender,'f',1,0))female,
            sum(decode(gender,'m',1,'f',1)) total from country group by cname

select *from country


select * from emp where sal<2000;

select d.dname from emp e,dept d where d.deptno not in(e.deptno)

select dname from emp,dept where emp.deptno not in(emp.deptno)

SELECT E.ENAME,E.SAL FROM EMP ,EMP E WHERE EMP.EMPNO=E.MGR

        AND EMP.SAL<E.SAL;

SELECT 
  *
FROM
  Emp e
WHERE
  TO_NUMBER(TO_CHAR(e.hiredate, 'DD')) <= 15
  
  
  
  select ename,sal from emp where sal>(select max(sal) from emp where deptno in(select deptno from dept where dname='SALES')) 
  
  select *from emp e where rowid =(select max(rowid) from emp b where e.empno=b.empno)
 
select *from emp where rowid <>(select max(rowid)from emp b where empno=b.empno)

select *from emp where rowid =select max(rowid) from emp

select *from emp
minus
select * from emp where rownum<=(select count(*)-&n from emp)


select min(sal)from emp where sal>(select max(sal)from emp e where emp.sal>e.sal)

Select Substr(�ORACLE�,Level,1) From Dual
Connect By Level<= Length(�ORACLE�);




select level from dual connect by prior level<100



select ename,sal, case when sal>1500 then 'Just salary'
                  when sal=1500 then 'On taget'
                  when sal< 1500 then 'Below 1500' end as salary from emp 




select trunc(add_months(sysdate,-1)+19) 'mon' from dual



commit


select *from country


select female.cname,female.female,male.male from 
(select cname,sum(case when gender='f' then 1 end) as female
              sum(case when gender='m' then 1 end) as male
    from country group by cname)

            
(select cname,sum(case when gender='m' then 1 end) as male from country group by cname) male where female.cname=male.cname

select * from emp
where (case when to_char(hiredate,'mon') = to_char(sysdate,'mon') then 'current' 
           when to_char(hiredate,'mon') = to_char(add_months(sysdate,-1),'mon') then 'previous'
           end) = 'previous'  
    
    
select  level, max(sal)
from   emp
where   level=2
connect  by
prior   sal>sal
group  by  level




select 
trunc(last_day('1-aug-18') - (
case 
  when to_char(last_day('1-aug-18'),'D') >= 6 then 
    to_char(last_day('1-aug-18'),'D')  - 6 
  else to_char(last_day('1-aug-18'),'D') + 1
end
))='&year' as last_friday
from dual



select 
trunc(last_day('&date') - 
case 
  when to_char(last_day('&date'),'D') >= 6 then 
    to_char(last_day('&date'),'D')  - 6 
  else to_char(last_day('&date'),'D') + 1
end
) as last_friday
from dual




select 
trunc(last_day(sysdate) - 
case 
  when to_char(last_day(sysdate),'D') >= 6 then 
    to_char(last_day(sysdate),'D')  - 6 
  else to_char(last_day(sysdate),'D') + 1
end
) as last_friday
from dual


select to_char(last_day(sysdate),'d')>=6 from dual;


SELECT NEXT_DAY(
         LAST_DAY( SYSDATE ) - INTERVAL '7' DAY,
         'FRIDAY'
       )
FROM   DUAL;


select rtrim('xxxxumaXXXXX','X') as name from dual;

select ltrim('xxxxumaXXXXX','X') as name from dual;

select ltrim('xxxxumaXXXXX','x') as name from dual;

select trim('x' from 'xxxxumaxxx') as name from dual;

select trim('    uma    ') as name from dual;

select trim('x' from 'xyxyxyumaxyxyxy') as name from dual;

select trim('x' from 'xxxxumayyyy') as name from dual;

select trim('y' from 'xxxxumayyyy') as name from dual;

select trim('x' from 'xxxxumaxxxx') as name from dual;

select trim('111uma111') from dual;


select ename,(case when to_char(hiredate,'dd')<=15 then to_char(hiredate,'month')
                     when to_char(hiredate,'dd')>15 then to_char(add_months(hiredate,1),'month') end) paymonth from emp
                     
                  
                  
select *from excel

update excel set order_date='11-dec-1991' where sales=1

insert into emp select *from s1                  
                     
                     

select * from excel
where (case when to_char(order_date,'dd-mon-yy') between  trunc(add_months(order_date,-1),'month')+19 and 
     trunc(add_months(order_date,0),'month')+20 then 'current'
            
    when to_char(order_date,'dd-mon-yy') between  trunc(add_months(order_date,-2),'month')+19  and
            trunc(add_months(order_date,-1),'month')+20 then 'previous' end)='&enter'
           
           
select * from excel where (case when to_char(order_date,'dd-mon-yy') between
trunc(add_months(order_date,-1),'month')+19 and trunc(add_months(order_date,0),'month')+20 then 'current'
 when to_char(order_date,'dd-mon-yy') between trunc(add_months(order_date,-2),'month')+19 and trunc(add_months(order_date,-1),'month')+20 then 'previous' end)='&enter'
           
           
           
           
select trunc(sysdate)from dual;
      
          
           
         
           ******&************&&&&************ EVERY MONTH LAST FRIDAY*********&&&*************&******



select to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1)-7),'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

            last week
            
select 'Last '||to_char(next_day(trunc(sysdate - 7 , 'D'),'MON') + lvl-1, 'Day')||' : '||
to_char(next_day(trunc(sysdate - 7 , 'D'),'MON') + lvl-1)
from (select level lvl from dual connect by level <= 5)



select to_char(next_day(last_day(add_months(to_date(:yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

select to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

select last_day(sysdate) - sysdate as days_left
from dual




select lpad(' ',rownum+1,'*')||ename as employees_name from emp

select rpad(' ',rownum+1,'@')||ename as employees_name from emp
select rpad(' ',rownum,'*')||ename from emp
select rpad(ename,rownum+4,'*') from emp

select ename||rpad(' ',rownum+2,'@')as employees_name from emp

select replace('she is very beautiful','ful','ma') from dual


select substr(ename,1,3) from emp;

select substr(ename,-3) from emp
select substr('umadevi',3,4) from dual

select instr('umarama','a',1,2) from dual
select instr('umarama','a',1,1) from dual where instr('umarama','a',1,1)>1


Write a query that displays the employee�s last names with the first letter capitalized and all other letters lowercase, 
and the length of the names, for all employees whose name starts with J, A, or M. Give each column an appropriate label. 
Sort the results by the employees� last names.

  select length(ename) "length",initcap(ename) "name" from emp where ename like 'J%' or ename like'A%' or ename like'M%' 
  
  select first_name as name,round((sysdate-hire_date)/365) as exp_of_years from employees
  
 select first_name as name,round(months_between(sysdate,hire_date)/12) as exp from employees
 
  select *from employees
  
  select add_months(sysdate,3) from dual

For each employee, display the employee�s last name, and calculate the number of months between today and the date the employee was hired. 
Label the column MONTHS_WORKED. Order your results by the number of months employed. Round the number of months up to the closest whole number.


select last_name,round(months_between(sysdate,hire_date)) "months_worked" from employees 


select max(salary) from employees where salary <(select max(salary) from employees)

select max(salary) from employees where salary <(select max(salary) from employees where salary <(select max(salary) from employees))


select distinct salary from employees
select max(salary) from employees

select round(avg(salary)) from employees where department_id=90

select department_id,max(salary) from employees group by department_id

select department_id,sum(salary) from employees group by department_id order by 1


For each employee, display the employee number, last_name, salary, and salary increased by 15% and expressed as a whole number. Label the column New Salary. 
Place your SQL statement in a text file named lab3_2.sql.

select employee_id,last_name,salary,round((salary*0.15)+salary) "new salary" from employees
select (salary*0.15)+salary from employees 

Select Employee_id,Last_name, Salary,Round(( Salary*(15/100)+salary)) as "New Salary" From 
Employees;


Modify your query lab3_2.sql to add a column that subtracts the old salary from the new salary. 
    Label the column Increase. Save the contents of the file as lab3_4.sql. Run the revised query. 

select Round(( Salary*(15/100)+salary)) - Salary as salary from employees


Write a query that produces the following for each employee: <employee last name> earns <salary> monthly but wants <3 times salary>. 
Label the column Dream Salaries.



select last_name||'earns'||' '||salary||' '||'monthly but wants' ||' '||salary*3  "dreame salaries" from employees

Create a query to display the last name and salary for all employees. 
Format the salary to be 15 characters long, left-padded with $. Label the column SALARY. 


select last_name,lpad(salary,15,'$') "salary" from employees 


Display each employee�s last name, hire date, and salary review date, which is the first Monday after six months of service. Label the column REVIEW. 
Format the dates to appear in the format similar to �Monday, the Thirty-First of July, 2000.�


select last_name,hire_date,salary,to_char(next_day(add_months(hire_date,6),'monday'),'day, "the" ddsp "of" month, yyyy') "review" from employees


SELECT last_name,hire_date,TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date, 6), 'Monday'),'DAY,"THE" DDSP "OF" MONTH YYYY') "REVIEW"
FROM employees;

select  to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') 
last_friday from emp connect by level<=12


select concat(ename) from emp
select ename

SELECT deptno, LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) AS employees
FROM   emp
group by deptno

select listagg(ename,'*') within group(order by ename) from emp;

select listagg(deptno,',') within group (order by deptno) from emp

select listagg(job,',') within group (order by deptno) from emp



Select length('she is a beautiful') - length(replace('she is a beautiful', ' ', '')) + 1 NumbofWords
from dual


select length('sachin is my favorate cricketer')-length(replace('sachin is my favorate cricketer',' ',''))+1 num_of_words from dual


select length('aravinda sametha is the famous film ntr is the actor')-
length(replace('aravinda sametha is the famous film ntr is the actor',' ',''))+1 no_of_words from dual 



select length('she is a beautiful') from dual

select reverse_words('rafi shaik') from dual;

select listagg(ename,',') within group(order by ename desc) from emp 

select listagg(deptno,'*') within group(order by deptno) from emp

select listagg(job,'@') within group(order by job) from emp
select listagg('ename',',') within group(order by ename desc)


select listagg(letter) within group(order by rn)
from 
 (SELECT rownum rn, SUBSTR ('hello world', rownum*-1, 1) letter 
 FROM   dual 
 CONNECT BY rownum <= length('hello world'));


select substr('shaik rafi',instr('shaik rafi',' ',1,1)+1)||' '||substr('shaik rafi',1,5) from dual;
 
select substr('shaik rafi',instr('shaik rafi',' ',1,1)+1)||' '|| substr('shaik rafi',1,instr('shaik rafi',' ',1,1)-1) from dual


select substr('shaik rafi',1,instr('shaik rafi',' ',1,1)-1) from dual

select  distinct (case when sal >3000 then sal end ) from emp
select sal from emp where sal>3000



select b.* (select emp a,emp b
                    start with job='MANAGER' connect by prior a.empno=b.mgr order by ename) from emp;
    



238.select max(sal) from emp e where e.sal<(select e1.sal from emp e1 where e1.empno=e.mgr) 


select * from emp where sal in
 (select max(sal) from emp where mgr in
 (select empno from emp where ename = 'KING')); 


List the highest paid emp of Chicago joined before the most recently hired emp
of grade 2.


select *from emp where sal=select max(sal) from emp e,dept d where e.deptno=d.deptno and d.loc='CHICAGO' and e.hiredate <
(select e.hiredate,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal  and s.grade=2)


select *from (select *from emp where job='MANAGER'
             union all
             select *from emp where job='CLERK')


select *from ((select *from emp where job='MANAGER') union all (select *from emp where job='CLERK')) WHERE JOB='&ENTER'


select *from ((select *from emp where deptno=10)union all (select *from emp where deptno=30)) where deptno='&enter'




&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&  practice queries  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&



 214..select d.dname,count(*) from emp e,dept d where e.deptno=d.deptno group by dname;

 select *from newemp

213. select dname,sum(sal) "total_salary" from emp e ,dept d where e.deptno=d.deptno group by dname


212..select e.ename "emp_name",m.ename "manager_name"  from emp e,emp m where m.empno=e.mgr

211..select e.ename,d.dname from emp e right join dept d on(e.deptno=d.deptno)

210..select e.empno,e.ename,d.loc from emp e join dept d on(e.deptno=d.deptno)

209..select e.empno,d.dname,e.ename from emp e join dept d on e.deptno=d.deptno

208..update emp set comm = comm*10/100 where comm is not null

207..update emp set comm=100 where comm is null

select *from emp


206..delete from emp where (sysdate-hiredate)/365>2

205..create table newemp as select e.empno,e.ename,d.dname from emp e,dept d where e.deptno=d.deptno

202..alter table newemp add deptno number(2)

select *from newemp

203..alter table newemp add constraint foreign key(deptno) references dept(deptno)

201..alter table emp add constraint foreign key(mgr) references dept(deptno)

200..alter table emp add mgr number(10)

199..alter table emp enable constraint emp_sal_chk

select *from emp

196..alter table emp drop column salary 

195..alter table emp modify ename varchar2(30)
desc emp

194..alter table emp add primary key(empno)

193..alter table emp1 add ename varchar2(20)

192..create table emp(empno number(4))

191..select empno,sal,sal*15/100 "pf" from emp

190..select ename from emp order by ename

188..select hiredate from emp where deptno in(select deptno from emp)

select substr(ename,1,1)||' '||ename from emp

commit



select hire_date,first_name,last_name from employees where to_char(hire_date,'yyyy')=2001
select *from employees

select initcap(first_name),initcap(last_name) from employees

select job_title,substr(job_title,instr(job_title,' ')-1)



SELECT SYSDATE,'hello', student_id, COUNT(*)
FROM enrollment
GROUP BY student_id

select *from  (select e.*,'abc' a from emp e where job='MANAGER'
            union all
            select e.*,'xyz' a from emp e where sal>3000) where a='&enter'


---Display the length of first name for employees where last name contain character �b� after 3rd position.

select length(first_name),last_name from employees where last_name like'__b%'
SELECT FIRST_NAME, LAST_NAME FROM EMPLOYEES WHERE INSTR(LAST_NAME,'B') > 3

select first_name,last_name from employees where instr(last_name,'b')>3



*********Display first name in upper case and email address in lower case for employees where the first name and email address are same irrespective of the case.



select upper(first_name),lower(email) from employees where upper(first_name)=upper(email)



********Display employees who joined in the current year.


select first_name,hire_date from employees where to_char(hire_date,'yyyy')=to_char(hire_date,'yyyy');


*******Display the number of days between system date and 1st January 2011.


select  round(sysdate-to_date('01-jan-2011')) from employees



******Display manager ID and number of employees managed by the manager.

select manager_id,count(*) from employees group by manager_id



********Display employee ID and the date on which he ended his previous job.


select employee_id,max(end_date) from job_history 



create table quarter(name varchar2(10),h_date date,sal number(10));
desc quarter
commit


select 3 from dual
intersect 
select 3 from dual;

select 3 from dual
union
select 3 from dual

select *from emp where rowid<5
select *from emp where rownum<=5

SELECT sysdate, systimestamp FROM dual;

select e.*, rownum from emp e order by rownum desc



select * from 
(select e.*,rownum rn from
(select * from emp  order by sal desc) e)
where rn=5;

select *from (select e.*,rownum rn from(select * from emp order by sal desc) e) where rn=6;

select max(sal), min(sal) from emp
where sal < (select max(sal) from emp)
and sal > (select min(sal) from emp);

select max(sal),min(sal) from emp
where sal<(select max(sal) from emp)
and 
sal > (select min(sal) from emp)


select *from emp where sal=(select min(sal) from(select *from (select sal from emp order by sal desc) where rownum<=2))

select ename name, connect_by_root(ename) boss 
     from emp 
     start with empno = 7839 
     connect by prior empno = mgr;

select replace('independence','e','mama') from dual

select translate('beer bucket','beer','milk') from dual
select replace('beer bucket','beer','milk') from dual


select *from tab
select *from customers
commit



SELECT *
FROM section
WHERE start_date_time BETWEEN
TO_DATE(&#39;31-DEC-2200&#39;,&#39;DD-MON YYYY&#39;)
AND TO_DATE(&#39;01/01/1900&#39;,&#39;MM/DD/YYYY&#39;)

select replace('s h a i k',' ','') from dual

select e.ename,d.deptno,sum(sal) 
from emp e,dept d
where e.deptno=d.deptno
group by e.ename,d.deptno
having sum(sal)>1200
order by d.deptno



select rtrim('Suresh*****','*') from dual


select lpad(' ',10-level,' ')|| lpad ('*', level, '*') from dual connect by level<=10
union all 
select lpad(' ',level,' ')|| lpad ('*', 10-level, '*') from dual connect by level<=9;



select lpad(' ',10-level,' ')||lpad('*',level-1,'*') 
||rpad('*',level,'*') from dual connect by level<=10




select ename, rownum from emp where (rowid,0) in (select rowid,mod(rownum,2) from emp )

select ename,rownum from emp where (rowid,1) in(select rowid,mod(rownum,2) from emp);


select * from emp
minus
select * from emp where rownum <= (select count(*) - &n from emp);

select ename, 12*(sal+nvl(comm,0)) as "annual Sal" from emp

select *from emp
minus
select *from emp where rownum<=(select count(*)-&n from emp)

select 12*sal+nvl(comm,0) as annual from emp

select distinct sal from emp e2 where &n = (select count(distinct sal) from emp e1 where e2.sal <= e1.sal);

 

select distinct sal from emp a where &n =  (select count(distinct sal) from emp b where a.sal <= b.sal);

select deptno,count(deptno)from emp group by deptno order by deptno

select * from emp  where sal> any(select sal from emp where sal<3000);

select *from emp 
minus
select *from emp e

SELECT  deptno, sum(sal) As totalsal
FROM emp
GROUP BY deptno
HAVING COUNT(empno) > 2

select deptno,sum(sal) from emp group by deptno having sum(sal)>2


select hiredate,to_char(add_months(sysdate,hiredate)/12) from emp

select round(to_char(sysdate-hiredate)/365) from emp 

select  distinct deptno from emp where deptno in(select deptno from dept where loc='DALLAS')

SELECT SUBSTR(ENAME,1,1),ENAME FROM EMP;


select decode(2,1,1
                2,1,3) from dual
                
                
                
    select cname, sum(  decode(gender,'m',1,0)) male,
               sum(  decode(gender,'f',1,0)) female,
               sum( decode(gender,'m',1,'f',1) ) total from country
               group by cname
               
               
select f.cname,f.female,m.male from  
    (select cname,sum(case when gender='f' then 1 end) as female from country) f 
    (select canem,sum(case when gender='m' then 1 end) as male from country) m
              where f.cname=m.cname    group by f.cname     
               
               
               select * from emp where rowid in (select decode(mod(rownum,2),0,rowid, null) from emp);
               
               select *from emp where rowid in(select decode(mod(rounum,2),0,rowid,null) from emp
               
               
               select ename,rownum from emp where (rowid,1) in(select rowid,mod(rownum,2) from emp)
               select rownum,ename from emp where (rowid,0) in(select rowid,mod(rownum,2) from emp)
               
               select lpad(' ',rownum+1,'*') || ename from emp
               
  create table departments(deptno number(10),gender varchar2(10))             
               
    select *from departments
    
     select male.deptno,male.male,female.female,total.total from
(select deptno ,sum(case when lower(gender)='male' then 1 else 0 end) male from  departments group by deptno) male,
(select deptno ,sum(case when lower(gender)='female' then 1 else  0 end) female from  departments group by deptno) female,
(select deptno ,sum(case when lower(gender)='male'then 1 when lower(gender)='female' then 1 end) total from  departments group by deptno) total
where male.deptno=female.deptno
and female.deptno=total.deptno          
        
             

commit

>>>>>>>>>>>>>>>>>>>>VIEW>>>>>>>>>>>>>>>

create view v1 as select *from emp;

select *from v1

create v2 as select e.first_name,e.last_name,e.phone_number,e.department_name,d.department_id
                    from employees e,departments d 
                    where e.department_id=d.department_id and d.department_name='Accounting'

select *from tab
select *from departments

create view v2 as select e.empno,e.sal,e.deptno,d.dname,d.loc 
             from emp e,dept d
              where e.deptno=d.deptno and d.loc='DALLAS';               

select *from emp

alter v2 set  e.ename='uma' where e.empno=7369  


rollback

update v2 set ename='uma' 

create or replace view v1
    as
    select a.ename, b.ename mgr_name
      from emp a, emp b
     where a.mgr = b.empno
      WITH CHECK OPTION
      
      
  CREATE VIEW
dept_sum_vu

(name, minsal, maxsal, avgsal)

AS SELECT
d.department_name, MIN(e.salary),

MAX(e.salary),round(AVG(e.salary))

FROM employees e, departments d

WHERE e.department_id = d.department_id

GROUP BY d.department_name;    

select *from dept_sum_vu;

select *from employees
               
create view count_view
(name,id,phone,doj,dname)
as select e.first_name,count(e.employee_id),e.phone_number,e.hire_date,d.department_name)
from employees e,departments d
where e.department_id=d.department_id
group by d.department_name,e.first_name,e.phone,e.hire_date;


create or replace view count_view as
select e.first_name,count(e.employee_id)"count_id",d.department_name
from employees e,departments d
where e.department_id=d.department_id
group by e.first_name,e.employee_id,d.department_name
having count(e.employee_id)>=1

select *from count_view


select 'small' "name",'0' "lower_bound",'1000' "upper_bound" from dual
union
select 'medium' "name",'1001' "lower_bound",'2000' "upper_bound" from dual
union
select 'large' "name",'2001' "lower_bound",'3000' "upper_bound"  from dual


create or replace view v1 as select *from emp;
insert into v1(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(1001,'UMA DEVI','MANAGER',1010,'10-sep-91',1000,null,10)
select *from v1

create or replace view emp_details as select deptno,count(*) "no_of_emp",min(sal) "minimum_sal",max(sal)
 "maximum_sal",avg(sal) "average_sal" ,sum(sal) "total_sal" from emp group by deptno;

update emp_details set deptno=50 where deptno=10
select * from  emp_details 


CREATE SEQUENCE sequence
[INCREMENT BY n]
[START WITH n]
[{MAXVALUE n | NOMAXVALUE}]
[{MINVALUE n | NOMINVALUE}]
[{CYCLE | NOCYCLE}]
[{CACHE n | NOCACHE}];

create sequence seq2
increment by 10
start with 10
maxvalue 100
minvalue 1
cache 20;

select seq2.currval from dual
select seq2.nextval from dual

insert into departments(department_id,department_name) values(departments.department_id_seq2.currval,'computers')

insert into dept(deptno,dname,loc)values(seq2.nextval,'computers','pune')

select *from dept
rollback
create sequence snc start with 4 minvalue 3 maxvalue 8 cycle
drop sequence se1

create or replace view empvu10
    (employee_no,employee_name,job_title) as select empno,ename,job
	 from emp where deptno=10 with read only;
     
     select *from empvu10
     
update empvu set employee_name='UMA' where deptno=10

create sequence seq1
 increment by 20


select *from((select 'small' "name",'0' "lower_bound",'1000' "upper_bound",1 a from dual)
union all
(select 'medium' "name",'1001' "lower_bound",'2000' "upper_bound", 2 a from dual)
union all
(select 'large' "name",'2001' "lower_bound",'3000' "upper_bound", 3 a  from dual)) where a=&n;

commit

create public synonym syn1 for scott.emp

select deptno,sum(sal) from emp
group by rollup(deptno);

select deptno,sum(sal),job from emp
group by rollup(deptno,job);

select deptno,sum(sal),job from emp
group by rollup(job,deptno);

select deptno,sum(sal),job from emp group by deptno rollup(job)


select *from emp
delete from emp where ename='UMA DEVI'

select ename, sal,
DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal)
from emp
--where ename = 'SMITH';



select case when grouping (deptno)=1 then 'Total'
   else cast(deptno as varchar2(20))
   end deptno, sum(sal) from emp 
    group by rollup(deptno)


set serveroutput on;
DECLARE
    a number(5) NOT NULL := 2
    name varchar2(15) := 'Branson Devs';
    ed CONSTANT varchar2(15) := 'Web Developer';
BEGIN
    dbms_output.put_line('Declared Value:');
    
    end;
   -- dbms_output.put_line(' Employee number: ' || eno || ' Employee Name: ' || ename);
    --dbms_output.put_line('Constant Declared:');
    --dbms_output.put_line(' Employee Department: ' || ed);    
END;


DECLARE
    pi CONSTANT REAL := 3.14159;
    radius REAL := 3;
    area REAL := (pi * radius**2);
BEGIN
    dbms_output.put_line(' PI: ' || pi || ' Radius: ' || radius);
    dbms_output.put_line(' Area: ' || area);    
END;



declare
 a number;
 b number;
 c number;
 begin
 a:=2;
 b:=3;
 c:=a+b;
 dbms_output.put_line('the sum of two numbers is :'|| c);
 end;
 
 commit
 
 begin
 null;
 end;
 ..............................................................................................
 
 ALL CURSOR ATTRIBUTES
 
 
 declare
cursor c1 is select ename from emp;
cursor c2 is select deptno from emp;
vename emp.ename%type;
vdeptno emp.deptno%type;
rowcount number;
begin
if not c1%isopen then
open c1;
end if;
loop
fetch c1 into vename;
exit when c1%notfound;
uma(vename);
end loop;
rowcount:=c1%rowcount;
uma('the no of employees are:'||' '||c1%rowcount);
close c1;
open c2;
fetch c2 into vdeptno;
while c2%found
loop
fetch c2 into vdeptno;
uma(vdeptno);
end loop;
close c2;
end;



commit
 
 
 
-------------------------------------------------------------------------------------------------------------------------------------------

drop table emp;

select *from emp;
select *from dept

CREATE TABLE emp(
  empno  NUMBER(4) CONSTRAINT empno_pk PRIMARY KEY,
  ename VARCHAR2(10),
  job           VARCHAR2(9),
  mgr    NUMBER(4),
  hiredate      DATE,
  sal        NUMBER(7,2),
  comm    NUMBER(7,2),
  deptno NUMBER(2) CONSTRAINT emp_deptno_fk REFERENCES dept(deptno)
);

INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,to_date('13-JUL-87','dd-mm-rr')-85,3000,NULL,20);
INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,to_date('13-JUL-87', 'dd-mm-rr')-51,1100,NULL,20);
INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
COMMIT;


set serveroutput on
declare 
fac number:=1;
n number:=&n;
begin
for i in 1..n
loop
fac:=fac*n;
n:=n-1;
end loop;
dbms_output.put_line(fac);
end;

set serveroutput on
declare
z exception;
vsal number;
begin
select sal into vsal from emp where empno=7902;
if vsal>2000 then
raise z;
else
update emp set sal=sal+100 where empno=7902;
end if;
exception when z then
raise_application_error(-20752,'salary alredy high');
end;

set serveroutput on
declare
z exception;
pragma exception_init(z,-1400);
begin
insert into emp(ename) values('uma');
exception when z then
uma('not to insert nulls');
end;


create or replace procedure first_proc(p_name in varchar2)
is
begin
dbms_output.put_line('hi hello'|| p_name);
end;

set serveroutput on
exec first_proc('what are u doing');

begin
first_proc;
end;

DECLARE 
   a number; 
   b number; 
   c number;
PROCEDURE first_proc(x IN number, y IN number, z OUT number) IS 
BEGIN 
   IF x < y THEN 
      z:= x; 
   ELSE 
      z:= y; 
   END IF; 
END;   
BEGIN 
   a:= 23; 
   b:= 45; 
   c:=a+b;
   dbms_output.put_line(' Minimum of (23, 45) : ' || c); 
END; 


commit

set serveroutput on
declare
cursor c1 is select deptno,dname from dept;
vdeptno dept.deptno%type;
vdname dept.dname%type;
begin
open c1;
loop
fetch c1 into vdeptno,vdname;
exit when c1%notfound;
dbms_output.put_line('the emplo 
yees of department is:'||' '||rpad(vdeptno,6)||' '||rpad(vdname,6));
declare
cursor c2(vdeptno number) is select * from emp where deptno=vdeptno;
empdet emp%rowtype;
begin
open c2(vdeptno);
loop
fetch c2 into empdet;
exit when c2%notfound;
dbms_output.put_line(rpad(empdet.ename,6)||' '||rpad(empdet.sal,6)||' '||rpad(empdet.deptno,6));
end loop;
close c2;
end;
end loop;
close c1;
end;


create table strength(sid number,sname varchar2(10),s_strength number);

insert into strength values(&sid,'&sname',&s_strength)
select *from strength

create or replace procedure pm(p_sname in varchar2,p_s_strength out number)
is
begin
select s_strength into p_s_strength from strength where sname=p_sname;
end;


variable x number;
set serveroutput on
exec pm('CSC',:x);

print x


create or replace function totalstrength
return integer
as 
total integer:=0;
begin
select sum(s_strength) into total from strength;
return total;
end totalstrength;




declare 
answer integer; 
  
begin 
answer:=totalstrength(); 
   dbms_output.put_line('Total strength of students is  ' || answer);   
end; 

select totalstrength(total) from totalstrength;



create or replace procedure p1(p_empno number)
is 
v emp%rowtype;
begin
select ename,sal,job into v.ename,v.sal,v.job from emp where empno=p_empno;
uma(v.ename||','||v.sal);
end;

set serveroutput on
exec p1(7839);
.......................
 Anonymous Block
 
 begin
 p1(7839);
end;
......................
set serveroutput on
call p1(7839);

commit

desc user_source;
select text from user_source where name='p1';

create or replace procedure p2(p_deptno number)
is
cursor c1 is select *from emp where deptno=p_deptno;
i emp%rowtype;
begin
open c1;
loop
fetch c1 into i;
exit when c1%notfound;
uma(i.deptno||' '||i.ename||' '||i.job||' '||i.sal);
end loop;
close c1;
end;

exec p2(10);

begin
p2(30);
end;


call p2(20);

variable d number;
set serveroutput on
declare
x number:=10;
begin
:d=x/2;
uma(d);
end;


create or replace procedure pp(p_ename in varchar2,p_sal out number)
is 
begin
select sal into p_sal from emp where ename=p_ename;
end;


variable z number
set serveroutput on
exec pp('KING',:z);
print z

declare
x number:=10;
begin
pp('ALLEN',x);
uma(x);
end;

create or replace 
commit

show error

create or replace procedure p4(p_empno emp.empno%type,
                                p_ename out emp.ename%type,
                                p_sal out emp.sal%type,
                                p_comm out emp.comm%type)
                                                       
is 
begin
select ename,sal,comm into p_ename,p_sal,p_comm from emp where empno=p_empno;
end;

commit
set serveroutput on
variable s_ename varchar2(20)
variable s_sal number
variable s_comm number
set serveroutput on
set autoprint on
exec p4(7902||' '||:s_ename||' '||:s_sal||' '||:s_comm);

create or replace procedure p11(p_empno in emp.empno%type,
                     p_job out emp.job%type,
                    p_deptno out emp.deptno%type)
is
begin
select job,deptno into p_job,p_deptno from emp where empno=p_empno;
end;


show error;

set serveroutput on
set autoprint on
variable g_job varchar2;
variable g_deptno number
exec p11(7902,:g_job,:g_deptno);
commit

CREATE OR REPLACE PROCEDURE format_phone
                         (p_phone_no IN OUT VARCHAR2)
IS
BEGIN
p_phone_no := '(' || SUBSTR(p_phone_no,1,3) ||
')' || SUBSTR(p_phone_no,4,3) ||
'-' || SUBSTR(p_phone_no,7);
END format_phone;

VARIABLE g_phone_no VARCHAR2(15)
BEGIN
:g_phone_no := &g_phone_no;
END;
select substr(job,1,3) from emp

create or replace procedure PE(p_empno  in number)
is
v_ename emp.ename%type;
v_job emp.job%type;
v_sal emp.sal%type;
v_hiredate emp .hiredate%type;
v_deptno emp.deptno%type;
begin
select ename,job,sal,hiredate,deptno into v_ename,v_job,v_sal,v_hiredate,v_deptno from emp where empno=p_empno;
uma(v_ename||' '||v_job);
end;

set serveroutput on
variable v_ename varchar2(10);
variable v_job varchar2(10);
variable v_sal number;
variable v_hiredate date;
variable v_deptno number;

exec PE(7499,:v_ename,:v_job,:v_sal,:v_hiredate,:v_deptno);

begin
PE(7499,:v_ename,:v_job,:v_sal,:v_hiredate,:v_deptno);
end;

begin
PE(7499);
end;

commit


select round(months_between(sysdate,hiredate)/12) from emp

select round((sysdate-hiredate)/365) "Years",
        trunc((sysdate-hiredate)/30) "Months",
        round(sysdate-hiredate) "Days" from emp where empno=7844

show error

 select 
       trunc(months_between(SYSDATE,hiredate)/12)||' '||'years' Years, 
      (TRUNC(months_between(SYSDATE,hiredate)-(TRUNC(months_between(SYSDATE,hiredate)/12)*12)))||' '||'months' Months,       
      trunc((months_between(sysdate,hiredate)-trunc(months_between(sysdate,hiredate)))*24)||' '||'days' Days,
      (trunc(sysdate-hiredate))*24 ||' '||'total hours' Total_Hours, 
      (trunc(sysdate-hiredate))*24*60 ||' '||'total mins' Total_Mins from emp

select (trunc(sysdate-hiredate))*24 "total hours" from emp
select  *from emp where empno=(select empno from emp where ename='KING') and job='MANAGER';
select *from emp

select trunc(months_between(SYSDATE,hiredate)-trunc(months_between(sysdate,hiredate)))*30) from emp



select 
       trunc(months_between(SYSDATE,hiredate)/12)||' '||'years' Years, 
      (TRUNC(months_between(SYSDATE,hiredate)-(TRUNC(months_between(SYSDATE,hiredate)/12)*12)))||' '||'months' Months,       
       trunc(sysdate - add_months(hiredate,trunc(months_between(sysdate,hiredate))))||' '||'days' Days ,
      (trunc(sysdate-hiredate))*24 ||' '||'total hours' Total_Hours, 
      (trunc(sysdate-hiredate))*24*60 ||' '||'total mins' Total_Mins from emp


select trunc(sysdate - add_months(hiredate,trunc(months_between(sysdate,hiredate)))) "days" from emp
select trunc(sysdate-add_months(hiredate,trunc(months_between(sysdate,hiredate)))) from emp
select add_months(hiredate,1) from emp
select add_months(hiredate,454) from emp
select *from emp

select trunc(sysdate-add_months(hiredate,trunc(months_between(sysdate,hiredate)))) from emp

select trunc(months_between(sysdate,hiredate)/12) years,
        (trunc(months_between(sysdate,hiredate)-trunc(months_between(sysdate,hiredate)/12)*12)) months,
        trunc(sysdate-add_months(hiredate,trunc(months_between(sysdate,hiredate)))) days from emp;
.....................................................

select months_between(sysdate,hiredate) from emp
select (trunc(months_between(sysdate,hiredate)/12)*12) from emp
select trunc((months_between(sysdate,hiredate)-(trunc(months_between(sysdate,hiredate)/12)*12))) "MONTHS" from emp

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

create or replace procedure pc(p_deptno in varchar2,p_cnt out number)
is 
begin
select count(*) into p_cnt from emp where deptno=p_deptno;
end;

variable c number
set serveroutput on
exec pc(20,:c);
print c;

create or replace procedure pa(a in out number)
is 
begin
a:=a+a;
end;

variable x number
set serveroutput on
exec :x:=2;
exec pa(:x);
print x

commit

declare
x number:=8;
begin
pa(x);
uma(x);
end;

create table tes (name varchar2(20));
insert into test1 values(&name)
select *from test1
desc test1
drop table test1
rollback

create or replace procedure ps
is
pragma autonomous_transaction;
begin
insert into tes values('India');
commit;
end;

select *from tes
exec ps
begin
insert into test values('hyd');
insert into test values('pune');
ps;
rollback;
end;

delete from tes
delete from test
drop table tes
drop table test1

create or replace procedure pd(p_empno in number)
is
i emp%rowtype;
v dept%rowtype;
begin
select ename,sal,job,hiredate,mgr into i.ename,i.sal,i.job,i.hiredate,i.mgr from emp where empno=p_empno;
uma(i.ename||' '||i.sal||' '||i.job||' '||i.hiredate||' '||i.mgr);
select dname,loc into v.dname,v.loc from dept where deptno=v.deptno;
uma(v.dname||' '||v.loc);
end;

set SERVEROUTPUT ON
exec e1(7839)

create or replace procedure e1(eempno number)
 is
 v emp%rowtype;
z dept%rowtype;
 begin
 select * into v from emp where empno=eempno;
uma(v.ename||' '||v.job||' '||v.sal||' '||v.deptno);
select * into z from dept where deptno=v.deptno;
uma(z.dname||' '||z.loc);
end;

commit

create or replace procedure p1(p_empno number)
authid current_user
is
v_ename emp.ename%type;
v_sal emp.sal%type;
begin
select ename,sal into v_ename,v_sal from emp where empno=p_empno;
uma(v_ename||' '||v_sal);
end;

exec p1(7839)
grant execute on p1 to hr;
set serveroutput on
exec scott.p1(7839);


create or replace function fun(a varchar2)
return varchar2
is
begin
return a;
end fun;

show error

select fun('hi welcome to stratapps') from dual;

begin
x varchar2;
begin
return('hi welcome to stratapps');
end;

select *from emp e where 0=(select count(distinct sal) from emp e1 where e1.sal>e.sal);

select *from emp e where 2=(select count(distinct sal) from emp e1 where e1.sal>e.sal);


create or procedure py
as
cursor c1 is hiredate,trunc(months_between(sysdate,hiredate)/12) years,
                      trunc(months_between(sysdate,hiredate)-(trunc(months_between(sysdate,hiredate)/12)*12)) months,
  
  commit                    

create or replace function fun(pdeptno number)
return number
is
cnt number;
begin
select count(*) into cnt from emp where deptno=pdeptno;
return cnt;
end;
 
show error 
select distinct fun(30) from emp;

set serveroutput on
declare
cnt number;
begin
cnt:=fun(30);
uma('the no of employees of 30 is:'||cnt);
end;


create or replace function func(pempno in number,pjob out varchar2,psal out number)
return varchar2
is 
vename emp.ename%type;
begin
select ename,job,sal into vename,pjob,psal from emp where empno=pempno;
return vename;
end;

set serveroutput on
declare
vename varchar2(20);
vjob varchar2(10);
vsal number;
begin
vename:=func(7839,vjob,vsal);
uma(vename);
uma(vjob);
uma(vsal);
end;



create or replace function fun_odd( a number)
return varchar2
is
begin
if mod(a,2)=0 then
 return 'even';
 else
 return 'odd';
 end if;
end;

select fun_odd(11)"even or Odd" from dual;

set serveroutput on
declare
c varchar2(20);
begin
c:=fun_odd(10);
uma(c);
end;


exec dbms_output.put_line(fun_odd(10)) 

create or replace function fun_2(pempno number)
return varchar2
as
v_ename varchar2(200);
pjob varchar2(200);
psal number(20);
begin
select ename,job,sal into v_ename,pjob,psal from emp 
where empno=pempno;
return v_ename||pjob||psal;
end; 

select fun_2(7839) from dual
with out writing out parameter


select *from year

select *from (select count(*) from year where month='feb' and renewal='R')"renewal" where cname='U'
select *from year where cid=100

select month,sum(decode(renewal,'N',1,0)) New_customer,
                sum(decode(renewal,'R',1,0)) Renewal,
                sum(decode(renewal,'N',1,'R',1)) Total from year group by month
                
                
select N.month,N.renewal,R.renewal,R.renewal+R.renewal total
from
(select month,sum(case when renewal='N' then 1 else 0 end) renewal from year group by month)N,
 (select month,sum(case when renewal='R' then 1 else 0 end) renewal from year group by month)R
 where N.month=R.month


select N.month,N.renewal,R.renewal,N.renewal+R.renewal total
from
(select month,sum(case when renewal='N' then 1 else 0 end) renewal from year group by month)N,
 (select month,sum(case when renewal='R' then 1 else 0 end) renewal from year group by month)R
 where N.month=R.month


create or replace function fun_gross(pempno number)
return number
is
gross number;
vsal number;
hra number;
da number;
pf number;
begin
select sal into vsal from emp where empno=pempno;
hra:=vsal*0.1;
da:=vsal*0.2;
pf:=vsal*0.1;
gross:=vsal+hra+da+pf;
return gross;
end;
show error

select fun_gross(7839) from dual
select *from emp



create or replace function fun_name(pempno in out number)
return varchar2
as
vename varchar2(10);
begin
select ename into vename from emp where empno=pempno;
return vename;
end;

set serveroutput on
declare
vempno number:=7839;
vename varchar2(10);
begin
vename:=fun_name(vempno);
uma('empno is :'||vempno||'and his name is '||vename);
end;


create or replace function f1(v1 number,v2 number)
return number
is
begin
if v1<v2 then
return v1;
else
return v2;
end if;
end;

select f1(30,20) from dual

create or replace function f2(len number,wid number)
return number
is
varea number;
begin
varea:=len*wid;
return varea;
end;

select f2(10,20) from dual

create table ac(acc number(10),amount_bal number);
insert into ac values(300,40000)
select *from ac

create or replace function fun_ac(pacc number)
return number
is
pamount_bal number;
begin
select amount_bal into pamount_bal from ac where acc=pacc;
return pamount_bal;
end;
show error

select fun_ac(300) from dual

commit

drop table trainee
select *from emp2
create or replace trigger trg1
before insert on emp2
for each row
begin
if :new.sal<5000 then
raise_application_error(-20182,'sal must be greater than 5000');
end if;
end;

insert into emp2(empno,sal,ename,deptno) values(1,2000,'uma',10)

create or replace trigger trg
before update or insert or delete on dept
for each row
begin
update emp2 set deptno=:new.deptno where deptno=:old.deptno;
end;

update dept set deptno=1 where deptno=10
select *from dept
roll back

create table dept_trg1(dname varchar2(10),loc varchar2(10),deptno number(10) primary key);

insert into dept_trg1(dname,loc,deptno) values('ACCOUNTING','HYD',10)

create or replace trigger trg
after delete on dept
for each row
begin
delete from dept_trg1 where dname='ACCOUNTING';
end;


delete from dept where dname='ACCOUNTING';
delete from dept where deptno=10

create or replace trigger trg2
before insert on emp2
for each row
begin
if :new.job='EXECUTIVE' then
raise_application_error(-20186,'there is a restriction');
end if;
end;

insert into emp2(empno,job,deptno) values(1,'EXECUTIVE',10)

create or replace function fn(pempno number,pdate date)
return number
is
z number;
begin
select months_between(pempno,hiredate)/12 into z from emp where empno=pempno;
return (round(z));
end;

DROP TABLE TEST

create table t1 as select *from emp where 1=2;
select *from t1;
desc t

create table trace(user varchar2(10),dod date)
show error

create table test(msg varchar2(20));

create or replace trigger trg_delete
after delete on emp
for each row 
begin
insert into test values('rec del');
end;

delete from emp where ename='SMITH'

select *from test

select *from emp
truncate table emp
INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
rollback

drop table emp
create table emp as select *from t


____________________ PPT ____________________________


create or replace trigger trg_nnd
before insert on dept
for each row
declare
cnt number;
begin
select count(*) into cnt from dept where dname=:new.dname;
if cnt>0 then
raise_application_error(-20165,'there is a restriction only one time insertion');
elsif :new.dname is null then
raise_application_error(-20186,'there is not a null value');
end if;
end;
show error

insert into dept(deptno,dname,loc)values(10,'ACCOUNTING','hyd')
insert into dept(deptno,dname,loc)values(10,null,'hyd')

......................................................

select *from t

create sequence s1 start with 1

create table trace(sno number primary key,name varchar2(20))

create or replace trigger tr2
before insert on trace 
for each row
begin
select s1.nextval into :new.sno from dual;
end;

insert into trace(name) values('uma')
insert into trace(name) values('uma')
insert into trace values('uma')

insert into trace(name) values('devi')
select *from trace

alter trigger tr2 disable 
select *from year
insert into year(year,month,cname)values(2018,'SEP','P');

create or replace trigger tr21
before insert on trace 
for each row
begin
:new.name:=upper(:new.name);
end;

desc user_triggers

select *from all_triggers
select *from trigger_types

create or replace trigger tr11
after delete on emp
declare
z number;
begin
select count(*) into z from emp;
uma(z);
end;

delete from emp where empno=7902

select *from trace
create or replace procedure pi
is 
pragma autonomous_transaction;
begin
insert into trace(name)values('priya');
commit;
end;

select *from trace
desc trace
alter trigger tr21 disable on trace
alter table trace disable all triggers

begin
insert into trace(name) values('darshini');
insert into trace(name) values('teja');
pi;
rollback;
end;

select *from tt

create or replace trigger trt
after insert or update or delete on tt
declare
z number;
begin
if inserting then 
z:='rows inserted';
elsif updating then
z:='rows updated';
elsif deleting then
z:='rows deleted';
end if;
insert into test values(z);
end;

delete from tt where id=13
update tt set name='karishma' where name='viggi'
select *from tt
create table test(msg varchar2(30))
select *from test

insert into tt(id,name)values(20,'kk');


commit

select *from t1
create table t3 as select *from t where 1=2;

create or replace trigger te2
after insert or update or delete on emp
for each row
begin
if inserting then
insert into t1(empno,ename,job)values(:new.empno,:new.ename,:new.job);
elsif updating then
insert into t2(empno,ename,job) values(:old.empno,:old.ename,:old.job);
elsif deleting then
insert into t3(empno,ename,job) values(:old.empno,:old.ename,:old.job);
end if;
end;

show error
select *from t2

insert into emp(empno,ename,job) values(20,'uma','team');
update emp set sal=sal+100 where empno=7839

drop table emp
create table emp as select *from t
select *from emp

commit

create or replace function fc(pdeptno number)
return number
is
cnt number;
begin
select count(*) into cnt from emp where deptno=pdeptno;
return cnt;
end;

select fc(20) from dual

create or replace function fs(pempno number)
return number
is
vsal number;
begin
select sal into vsal from emp where empno=pempno;
return vsal;
end;

select fs(7369) from dual


create table test(id number(10),description varchar2(100));







********************** PRACTICR FOR PLSQL EXAM *********************

 ..........> 1. to display experiance of the employee for passing empno and date as parameters....
 
 
create or replace function fd(pempno number,pdate date)
return number
is
z number;
begin
select months_between(pdate,hiredate)/12 into z from emp where empno=pempno;
return (round(z));
end;

select ename,sal,hiredate,fd(empno,sysdate) from emp where empno=7369

..............................................

.....>2. To passing empno as parameter and display gross salary of that employee for the following condition

create or replace function fun_gross(pempno number)
return number
is
vsal number(10);
hra number;
da number;
pf number;
gross number;
begin
select sal into vsal from emp where empno=pempno;
hra:=vsal*0.1;
da:=vsal*0.2;
pf:=vsal*0.1;
gross:=vsal+hra+da-pf;
return gross;
end;

select fun_gross(7566) from dual

....................................................

............> 3. write a plsql stored function for passing parameter as empno and calculate the tax for given condtions

create or replace function fun_tax(pempno number)
return number
is
vsal number;
annsal number;
it number;
begin
select sal into vsal from emp where empno=pempno;
annsal:=vsal*12;
if annsal>1000 and annsal<=15000 then
it:=annsal*0.1;
elsif annsal>15000 and annsal<=20000 then
it:=annsal*0.2;
elsif annsal>20000 then
it:=annsal*0.3;
else
it:=0;
end if;
return it;
end;

show error

select fun_tax(7369) from dual
..............................................

.........>4. display plsql function passing parameter as deptno and display the no of employees on that department............

create or replace function fun_dept(pdeptno number)
return number
is
cnt number;
begin
select count(*) into cnt from emp where deptno=pdeptno;
return cnt;
end;

select fun_dept(30) from dual;

...............................................

.............> 5. write a plsql function to find the area of a circle......... 

create or replace function fun_area(len number,wid number)
return number
is
varea number;
begin
varea:=len*wid;
return varea;
end;

select fun_area(10,40) from dual

..........................................................

..........> 6. write a plsql program to display the least number of the list(20,40,60);

create or replace function fun_least(n1 number,n2 number,n3 number)
return number
as
begin
if n1>n2 then
return n1;
elsif n2>n3 then
return n2;
elsif n3>n1 then
return n1;
end if;
end;

select fun_least(20,40,60) from dual
.......................................

......> 7. write a plsql function accept account number and return account balance of the customer.

create table account(acc_no number(14),cname varchar2(20),bal number(10))

insert into account values(&acc_no,'&cname',&bal)

create or replace function fun_account(pacc_no number)
return number
is
vbal number;
begin
select bal into vbal from account where acc_no=pacc_no;
return vbal;
end;

select *from account

show error

...........................................

*************   ******** ****** PROCEDURES ***** ********* ************

    1. create a procedure for passing empno and display ename and sal of the employee.

create or replace procedure proc1(pempno number)
as
vename varchar2(20);
vsal number;
begin
select ename,sal into vename,vsal from emp where empno=pempno;
dbms_output.put_line(vename||' '||vsal);
end;

set serveroutput on
show error
exec proc1(7902)

.............................................

    2. write a plsql procedure to passing a deptno as parameter and display all the employees details.

create or replace procedure proc_dept(pdeptno number)
as
cursor c is select *from emp where deptno=pdeptno;
i emp%rowtype;
begin
open c;
loop
fetch c into i;
exit when c%notfound;
uma(i.ename||' '||i.sal||' '||i.job||' '||i.hiredate);
end loop;
close c;
end;

set serveroutput on
exec proc_dept(10)

begin
proc_dept(20);
end;

select *from emp

select *from emp where deptno=20

............................................................

 3. how to insert a row into a plsql procedure
 
 create or replace procedure proc_insert(pdeptno in number,pdname in varchar2,ploc in varchar2)
 is
 begin
 insert into dept values(pdeptno,pdname,ploc);
 uma('record inserted to department through procedure');
 end;
 
show error
rollback
select *from dept
exec proc_insert(50,'CREDIT_CARDS','hyd')
.......................................................

************** ********* TRIGGERS *********** *****

...........> 1. write a plsql row level trigger on emp table whenever inserting data on table sal should be more than 5000.

create or replace trigger trg1
before insert on emp2
for each row
begin
if :new.sal<5000 then
raise_application_error(-20182,'sal must be greater than 5000');
end if;
end;

insert into emp2(empno,ename,sal) values(11,'uma',2000);

ORA-20182: sal must be greater than 5000
ORA-06512: at "SCOTT.TRG1", line 3
ORA-04088: error during execution of trigger 'SCOTT.TRG1'

...............................................................

......> 2. write a plsql trigger update the deptno on dept table automatically those deptno's modified on employees table also'

create or replace trigger trg
before update or insert or delete on dept
for each row
begin
update emp2 set deptno=:new.deptno where deptno=:old.deptno;
end;

update dept set deptno=1 where deptno=10
select *from dept
roll back

...................................................................

 ...... > 3. Auto Increment...
 
 create sequence s2 start with 1

create table trace(sno number primary key,name varchar2(20))

create or replace trigger tr2
before insert on trace 
for each row
begin
select s2.nextval into :new.sno from dual;
end;

insert into trace(name) values('uma')
insert into trace(name) values('sri love')

insert into trace(name) values('devi')
select *from trace

...................................................

........> 4. write a plsql statement level trigger on emp table do not perform dml operations on weekdays.


create or replace trigger tr_weekday
before insert or update or delete on emp
begin
if to_char(sysdate,'dy') in ('sat','sun') then
 raise_application_error(-20181,'we cont perform dml operations on sat and sun');
end if;
end;

alter table emp enable all triggers

delete from dept where deptno=10
select *from emp
rollback

...................................................................

 ..........> 5. write a plsql statement level trigger on emp table do not perform dml operations on last day of the month.

create or replace trigger trg_lastday
before insert or update or delete on emp
begin
if sysdate=last_day(sysdate) then
raise_application_error(-20123,'we dont perform dml operations on last day of the month');
end if;
end;

................................................

....> write a plsql trigger using emp,dept table implement on delete cascade concept, without using on delete clause.

create or replace trigger trg_delete
after delete on dept
for each row
begin
delete from emp where deptno=:old.deptno;
end;


......> 6. write a plsql statement level trigger on emp table do not perform any dml operations on any days.

create or replace trigger trg_dml
before insert or update or delete on emp
begin
if inserting then
raise_application_error(-20134,'we cant perform inserting operation');
elsif updating then
raise_application_error(-20134,'we cant perform updating operation');
elsif deleting then
raise_application_error(-20134,'we cant perform deleting operation');
end if;
end;

insert into emp(ename,sal) values('uma',20000);

ORA-20134: we cant perform inserting operation
ORA-06512: at "SCOTT.TRG_DML", line 3
ORA-04088: error during execution of trigger 'SCOTT.TRG_DML'

.......................................................................

......> 7. if any dml operations done on emp table that msg was entered in test table.

select *from test

desc test
create or replace trigger trg_msg
after insert or update or delete on emp
declare
z varchar2(100);
begin
if inserting then
z:='rows inserted';
elsif updating then
z:='rows updated';
elsif deleting then 
z:='rows deleted';
end if;
insert into test values(z);
end;

show error
insert into emp(ename) values('uma')

alter table emp enable all triggers
create table test (msg varchar2(100))

select *from test
.....................................................................

.........> 8. write a plsql row level trigger if inserting on emp table that values stored in another table,
              if updating on emp table those values are stored on another table,
              if deleted on emp table those values are stored on enother table.

create or replace trigger te2
after insert or update or delete on emp
for each row
begin
if inserting then
insert into t1(empno,ename,job)values(:new.empno,:new.ename,:new.job);
elsif updating then
insert into t2(empno,ename,job) values(:old.empno,:old.ename,:old.job);
elsif deleting then
insert into t3(empno,ename,job) values(:old.empno,:old.ename,:old.job);
end if;
end;

insert into emp(empno,ename,job) values(1001,'uma','executive');

alter table emp enable all triggers
select *from t1

.....................................................................................

......> 9. 
drop table x
create table x(col1 number(3),col2 number(3),col3 date)

create sequence s3 start with 5878

create or replace trigger trg_col
before insert on x
for each row
begin
select s3.nextval into :new.col1 from dual;
dbms_output.put_line('t1 fired');
end;

show error

insert into emp(ename,sal,deptno) values('uma',20000,10)

alter table emp enable all triggers
select *from x


create or replace trigger trg_col1
before insert on x
for each row
declare
v_col2 varchar2(20);
begin
select to_char(reverse(:new.col1)) into v_col2 from dual;
:new.col2:=v_col2;
uma('t2 fired');
end;
show error

insert into x(col3) values(sysdate)
select *from x

create or replace trg_col2
before insert on x
for each row
follows trg_col1,trg_col
declare
.........
...........
...........
end;

commit
........................................................................................

create table sum(totsum number(4))

create or replace procedure proc_sum
is
z number;
begin
delete from sum;
select sum(sal) into z from emp;
insert into sum values(z);
end;

create or replace trigger trg_proc
after insert or update or delete on emp
call proc_sum

insert into emp(ename,job,sal) values('uma','teamlead',20000)
update emp set sal=sal+100 where empno=7369
select *from sum
exec proc_sum(z)
alter table emp enable all triggers
 select *from emp
roll back

delete from dept where deptno=10
roll back
select *from dept

....................................................................

create or replace trigger trg_nnd
before insert on dept
for each row
declare
cnt number;
begin
select count(*) into cnt from dept where dname=:new.dname;
if cnt>0 then
raise_application_error(-20165,'there is a restriction only one time insertion');
elsif :new.dname is null then
raise_application_error(-20186,'there is not a null value');
end if;
end;
show error

insert into dept(deptno,dname,loc)values(10,'ACCOUNTING','hyd')
insert into dept(deptno,dname,loc)values(10,null,'hyd')


drop table emp
create table emp as select *from t
select *from emp

delete from dept where deptno=10

create or replace trigger trg_delete
after delete on dept
for each row
begin
delete from emp where deptno=:old.deptno;
end;

delete from dept where deptno=20
select *from dept

rollback
insert into dept(deptno,dname,loc) values(10,'ACCOUNTING','NEW YORK')

create or replace function fun_dept(pdeptno number)
return varchar2
is
cursor c is select *from emp where deptno=pdeptno;
i emp%rowtype;
begin
open c;
loop
fetch c into i;
exit when c%notfound;
return(i.ename||' '||i.job||' '||i.sal||' '||i.hiredate||' '||i.deptno);
end loop;
close c;
end;

select fun_dept(20) from dual



create or replace function fun_cnt(pdeptno number)
return number
is
cnt number;
begin
select count(*) into cnt from emp  where deptno=pdeptno;
return (cnt);
end;

select fun_cnt(10) from dual


create or replace procedure proc_emp_dept(pempno number)
is
i emp%rowtype;
v dept%rowtype;
begin
select ename,sal,job,deptno into i.ename,i.sal,i.job,i.deptno from emp where empno=pempno;
uma(i.ename||' '||i.sal||' '||i.job);
select deptno,dname,loc into v.deptno,v.dname,v.loc from dept where deptno=i.deptno;
uma(v.deptno||' '||v.dname||' '||v.loc);
end;

exec proc_emp_dept(7844) 
set serveroutput on

 commit
 

*********************  *************** PACKAGES IN PLSQL *********** ***********************
 
 .............> ADDITION OF TWO NUMBERS..............

create or replace package pack_a
is
procedure p1(a in number,b in number, c out number);
function fun_mul(x number,y number,z out number);
return number;
end;

show error

create or replace package body pack_a
as
procedure p1(a in number,b in number,c out number)
is
begin
c:=a+b;
uma('the addition of two numbers is:'||c);
end p1;
end pack_a;

show error
 
exec pack_a.p1(10,20,:c);
set serveroutput on

 .....................> MULTIPLICATION OF TWO NUMBERS...............
 
 create or replace package pack_mul
 is
 function fun_mul(x in number,y in number)
 return number;
 end pack_mul;
 
 
 create or replace package body pack_mul
 as
 function fun_mul(x in number,y in number)
 return number 
 is 
 c number;
 begin
 c:=x*y;
 return c;
 end fun_mul;
 end pack_mul;
 
 show error
 select pack_mul.fun_mul(10,5) from dual;
 
 ...............................................
 
 create or replace package pack_am
 is
 procedure proc_add(a in number,b in number,c out number)
 function fun_mul(x in number, y in number)
 return number;
 return number;
 end pack_am;
 
 show error
 
 
 create or replace procedure proc_del(pjob emp.job%type,pcnt out number)
 is
 cursor c is select job from emp where job=pjob;
 v c%rowtype;
 begin
 open c;
 loop
 fetch c into v;
 exit when c%notfound;
 delete from emp where job=pjob;
 end loop;
 pcnt:=c%rowcount;
 close c;
 end;
 
 set serveroutput on
 declare
 pcnt number;
 begin
 proc_del('ANALYST',pcnt);
 uma(pcnt||'employees are deleted');
 end;

 select *from emp
 rollback
 
 create or replace procedure proc_exp
 as
 cursor c is select hiredate,trunc(months_between(sysdate,hiredate)/12)||'years' years,
                        (trunc(months_between(sysdate,hiredate)-(trunc(months_between(sysdate,hiredate)/12)*12)))||'months' months,
                        trunc(sysdate-add_months(hiredate,trunc(months_between(sysdate,hiredate))))||'days' days from emp;
v c%rowtype;
begin
open c;
loop
fetch c into v;
exit when c%notfound;
uma(v.hiredate||' '||v.years||' '||v.months||' '||v.days);
end loop;
end;
 
 set serveroutput on
 exec proc_exp
 
 commit
 
 
 create or replace package pack_sum
 is
 procedure proc_add(a number,b number);
 function fun_mul(x number,y number)
 return number;
 end pack_sum;
 
 show error
 
 create or replace package body pack_sum
 is
 procedure proc_add(a number,b number)
 is
 c number;
 begin
c:=a+b;
uma(c);
end proc_add;
function fun_mul(x number,y number)
return number
is
c number;
begin
c:=x*y;
return c;
end fun_mul;
end pack_sum;

exec pack_sum.proc_add(10,20);
select pack_sum.fun_mul(10,20) from dual;
...........................................................
show error
 
 create or replace procedure e1(eempno number)
 is
 v emp%rowtype;
z dept%rowtype;
 begin
 select * into v from emp where empno=eempno;
uma(v.ename||' '||v.job||' '||v.sal||' '||v.deptno);
select * into z from dept where deptno=v.deptno;
uma(z.dname||' '||z.loc);
  end;
 
 set serveroutput on
  exec e1(7369) 
 
 
 create or replace procedure p1(pempno number)
 is
 v emp%rowtype;
 i dept%rowtype;
 begin
 select * into v from emp where empno=pempno;
 uma(v.ename||' '||v.sal||' '||v.hiredate);
 select * into i from dept where deptno=v.deptno;
 uma(i.dname||i.loc);
 end;
 
exec p1(7844)
 
 select *from user_triggers
 select count(*) from user_triggers where table_name='DEPT'
 
 select tr2 from user_triggers where table_name='EMP';
 
 
 commit
 
 
 
 create or replace function fun_2(pempno number)
return varchar2
as
v_ename varchar2(200);
pjob varchar2(200);
psal number(20);
begin
select ename,job,sal into v_ename,pjob,psal from emp 
where empno=pempno;
return v_ename||' '||pjob||' '||psal;
end; 

select fun_2(7839) from dual
with out writing out parameter
 
 
 create or replace procedure proc_sal(pename varchar2)
 is
 vsal number;
 begin
 select sal into vsal from emp where ename=pename;
 uma(vsal);
 end;
 
exec proc_sal('SMITH')

create or replace trigger trg_cnt
after delete on emp
for each row
declare
cnt number;
begin
select count(*) into cnt from emp;
uma(cnt);
end;
commit


create procedure display1(a varchar2)
is
begin
dbms_output.put_line(a);
end;

set serveroutput on
begin
display1('umadevi');
end;

select *from account
update account set acc_type='c' where acc_no=555


alter table account add  acc_type varchar2(10)



create or replace procedure account_bank(pacc_no in number,p_wd in number)
is
re number;
v_bal number;
v_acc_type varchar2(10);
begin
select bal,acc_type into v_bal,v_acc_type from account where acc_no=pacc_no;
re:=v_bal-p_wd;
if
re<3000 and v_acc_type='s'
then
raise_application_error(-20888,'we cannot withdraw less than 3000');
elsif re<5000 and v_acc_type='c'
then
raise_application_error(-20123,'minimus balance should be 5000');
else
dbms_output.put_line('transaction sucessfully completed');
end if;
end;

exec account_bank(333,11000);

select *from account

commit
------------------------------------------------------------------------------------------------------------------------------

select upper('uma') from dual

select *from emp where ename like 'M%';

select *from emp where ename like'%R';

select *from emp
minus
select *from emp where rownum<=(select count(*)-5 from emp); 



---------------------------------------------------------------------------------------------------------------------------------------------



select '1'+'1' from dual

select empno+mgr from emp

select ename+job from emp

select decode(null,null,'Null','Not Null') from dual

select case null when null then 'Null'
            else 'Not Null' end  from dual

commit

select






  FINAL SQL PRACTICE STUDENT SCHEMA

select *from student

select last_name from student where zip in(10048,11102,11209)

select *from instructor

select *from instructor where first_name like '%i%' or last_name like'%I%' and zip in(10025);

select *from course

select description from course where cost<1100
select description,cost ,prerequisite from course where cost<1100 and prerequisite is not null

select course_no,rpad(course_no,10,'.')||description from course order by description

select first_name||' '||last_name,phone "new_phone" ,nvl(phone,'223-657-9872') from student  

select count(distinct student_id) from enrollment

select course_no,cost,avg(nvl(cost,0)) from course group by course_no,cost
select avg(nvl(cost,0)) from course

select substr('uma janu love',1,instr('uma janu love',' ',1,1)-1) first_name from dual
select substr('uma janu love',instr('uma janu love',' ',1,1),
(instr('uma janu love',' ',1,2)-instr('uma janu love',' ',1,1))) "second_name"from dual

select substr('uma janu love',instr('uma janu love',' ',1,2)+1) last_name from dual

select substr('siva rama krishna',instr('siva rama krishna',' ',1,1),
(instr('siva rama krishna',' ',1,2)
-instr('siva rama krishna',' ',1,1))) "middle name" from dual;


select substr('amar akbar antony',1,instr('amar akbar antony',' ',1,1)-1) "first_name" ,
       substr('amar akbar antony',instr('amar akbar antony',' ',1,1),
             (instr('amar akbar antony',' ',1,2)-instr('amar akbar antony',' ',1,1))) "second_name",
       substr('amar akbar antony',instr('amar akbar antony',' ',1,2)+1) last_name from dual

commit

select *from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>=e.sal)


select *from emp where rownum<=(select count(*)-9 from emp)
select *from emp
minus
select *from emp where rownum<=(select count(*)-5 from emp)

commit

---------------------------------------------------------------------------------------------------------------------

create table a(id number(2))
insert into a(id) values(30)
create table b(id number)
insert into b(id) values(70)
select *from b
select *from a

select *from a
intersect
select *from b

select *from a
union
select *from b

select *from a
union all
select *from b

update a set id=case when id=10 then id+2
                        when id=20 then id+20
                        else
                        id end
select *from a

rollback

select *from emp e where 10=(select count(distinct sal) from emp e1 where e1.sal>e.sal)
select *from emp e where 0=(select count(distinct sal) from emp e1 where e1.sal>e.sal)
select *from emp

select *from emp where empno%2=0

select *from b
insert into b(id) values(30)

select sum(id=case id when id>0 then id else 0)sum_posi , sum(id=case id when id<0 then id else 0 end)sum_neg from b
update b set sum(id=case when id>0 then id else 0 end) sum_pos 

select *from b

select sum(case when id<0 then id else 0)sum_neg from b

create table gms(weight number)

insert into gms(weight) values(65)
select *from gms

 weight,trunc(weight) kg,
select trunc(weight) kg from gms
select 

select weight,trunc(weight) kg,nvl(substr(weight-trunc(weight),2),0) gms from gms

select empno,ename,count(empno) from emp group by empno,ename having count(empno)>1

select e.*,count(*) over(partition by ename,empno)s from emp e

select empno,ename,count(*) from emp group by empno,ename having count(*)>1

create table color(no number,name varchar2(10))
insert into color(no,name) values(16,'orange')
select *from color
drop table color

select no,name,count(rowid) from color group by no,name having count(rowid)>1

select *from emp where rowid not in(select max(rowid) from emp group by empno)
select *from color where rowid not in(select min(rowid) from color group by name)

select *from(e.*,count(*) over(partition by empno) cnt from emp e) where cnt>1
select empno from emp group by empno having count(empno)>1

select *from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>e.sal)

create or replace procedure p_t
is
begin
uma('i am very beautiful today');
end;

create or replace procedure p_t1
is
begin
uma('u r not looking good today');
p_t;
end;

set serveroutput on
exec p_t
exec p_t1


show error
......................................................................................
create or replace procedure top_sal
is
cursor c1 is select  sal from emp order by sal desc;
v_sal number;
begin
open c1;
loop
fetch c1 into v_sal;
uma(v_sal);
exit when c1%rowcount=6;
end loop;
uma('top 6 employees');
close c1;
end;
........................................................................................

commit
exec top_sal
set serveroutput on
show error

select *from
    (
    select *from emp 
    order by sal desc
    )
where rownum <= 6
order by sal desc;

.................................................................................................
create table old_dept(deptno number,dname varchar2(10),loc varchar2(20))

create or replace procedure p_dept
is
cursor c1 is select *from dept;
i dept%rowtype;
begin
open c1;
loop
fetch c1 into i;
exit when c1%notfound;
insert into old_dept values(i.deptno,i.dname,i.loc);
end loop;
uma('the no of rows are:'||c1%rowcount);
close c1;
end;

show error
set serveroutput on
exec p_dept
select *from old_dept

...............................................................................................................

create or replace procedure p_empdetails(p_deptno in number)
is
cursor c1 is select *from dept where deptno=p_deptno;
cursor c2 is select *from emp where deptno=p_deptno;
i dept%rowtype;
v emp%rowtype;
begin
open c1;
loop
fetch c1 into i;
exit when c1%notfound;
dbms_output.put_line(i.deptno||' '||i.dname||' '||i.loc);
end loop;
close c1;
open c2;
loop
fetch c2 into v;
exit when c2%notfound;
dbms_output.put_line(v.ename||' '||v.job||' '||v.hiredate||' ' ||v.sal);
end loop;
close c2;
end;

show error

exec p_empdetails(20)
.........................................................................................................

create or replace procedure proc_del(p_job in varchar2)
is
begin
delete from emp1 where job=p_job;
uma('deleted records are:'||sql%rowcount);
end;

SHOW ERROR
set serveroutput on
exec proc_del('MANAGER')

begin
uma('deleted job details');
proc_del('CLERK');
end;

SELECT *FROM EMP
....................................................................................................

create or replace procedure proc_del(p_job in varchar2,cnt out number)
is
i number;
begin
select count(*) into i from emp1 where job=p_job;
delete from emp1 where job=p_job;
uma('deleted records are:'||i);
end;


show error
declare
x varchar2(20);
begin
proc_del('CLERK',x);
uma('deleted job details');
end;

SELECT *FROM EMP1

.............................................................................

create or replace function fun_del(p_job in varchar2)
return number
is
cnt number;
begin
select count(*) into cnt from emp where job=p_job;
delete from emp where job=p_job;
uma('deleted rows are:'||cnt);
end;

show error

select fun_del('CLERK') from dual


commit


-------------------------------------------------------------------------------------------------------------------------

select trunc(sysdate,'mm')-1 from dual;

select last_day(add_months(sysdate,-1)) from dual

select table_name,num_rows from user_tables where table_name='EMP'

select 'stratapps solutions',regexp_count('stratapps solutions','s') from dual

select years from ( select to_char(sysdate,'yyyy') - 70 + level years,
                    case when mod(to_char(sysdate,'yyyy') - 70 + level,4) = 0 then 'Leap Year'
                    end "Leap"
                    from dual
                    connect by level <= 70) 
where "Leap" is not null;    


select sum(1) from dual
select sum(2) from dual
select sum(2) from emp
0



select null+null from dual...........(null)
select null+1 from dual ..........(null)
select null(null(null(null))) from dual ..............error
select ename name from emp order by name
select ename "Name" from emp order by "Name"
create table uu(name varchar2(10),gender varchar2(2))
insert into uu values('&name','&gender')

update uu set gender=case when gender='m' then 'f'
            else 'm' end 
rollback

select *from uu
commit
select ename,empno,sum(sal) 
from emp 
where job='MANAGER'
group by empno
having sum(sal)>2000
order by 1




create table source(cust_id number(4),cname varchar2(10),c_loc varchar2(10))

insert into source values(&cust_id,'&cname','&c_loc')

create table target1(cust_id number(3),cname varchar2(10),c_loc varchar2(10))

create sequence see1 start with 1

create or replace trigger trg_target1
after insert or update  on source 
for each row
begin
if inserting then 
insert into target1(cust_id,cname,c_loc)values(:new.cust_id,:new.cname,:new.c_loc);
elsif updating then 
update source set cust_id=:new.cust_id where cust_id=:old.cust_id;
end if;
end;


create or replace trigger trg_ssq
before insert or update on target1
for each row
begin
select see1.nextval into :new.cust_id from dual;
end;

insert into target1 values('harish','newyork')

update source set c_loc='banglor' where cname='uma'

alter trigger trg

desc target1
show error
select *from source

insert into source values(&cust_id,'&cname','&c_loc')


commit

--------------------------------------------------------------------------------------------------------------------------------

create table bank_acc(name varchar2(20),balance number)

insert into bank_acc values('&name',&balance)

select *from bank_acc

create or replace procedure bank1(p_name in varchar2,p_depamt in number)
is
p_accbal1 number;
p_accbal2 number;
begin
select balance into p_accbal1 from Bank_acc where name=p_name;
select balance into p_accbal2 from Bank_acc where name='B';
if
p_depamt>p_accbal1 then
raise_application_error(-20813,'insufficent founds to transfer');
elsif p_depamt<=0 then
raise_application_error(-20881,'enter valid amount');
elsif p_depamt<=p_accbal1 then
update Bank_acc set balance=p_accbal2+p_depamt where name='B';
update Bank_acc set balance=p_accbal1-p_depamt where name='A';
end if;
end;

exec bank1('A',3100)
exec bank1('A',2500)
exec bank1('B',1700)


......................................................................................................

select sum(2) from dual
select ('uma') from dual
select 'uma' from dual
select 'uma''''devi' from dual
select sal from emp where sal not in(2000,5000)
select sal from emp where sal between 2000 and 5000
select sal from emp where sal not between 2000 and 5000
select *from emp where comm is null
select *from emp where comm is not null
select 1/2 from dual
select ('1'|| '2'|| '3'|| '4'|| '5') from dual
select (25/255) from dual
select months_between(sysdate,sysdate) from dual
select round(months_between(sysdate,'10-sep-1990')) from dual
select (round(months_between(sysdate,'10-sep-1990'))/12) from dual
select months_between('12-dec-2018'||' '||'12-dec-1991') from dual



--------------------------------------------------------------------------------------------------------------------------------------------------




                                        ************ PL SQL ************

set serveroutput on                                  
                                        
Declare
a number;
sum1 number :=0;
Begin
a:=1;
loop
sum1:=sum1+a;
exit when (a=100);
a:=a+1;
end loop;
dbms_output.put_line('Sum between 1 to 100 is '||sum1);
End;

declare
    str1 varchar2(50):='&str';
    str2 varchar2(50);
    len number;
    i number;
 begin
    len:=length(str1);
        for i in reverse 1..len
    loop
        str2:=str2 || substr(str1,i,1);
    end loop;
        dbms_output.put_line('Reverse of String is:'||str2);
end;

commit

declare
a number;
begin
a:=200;
dbms_output.put_line('the value of a is:'||a);
     declare
        n number:=500;
        v_tot number;
        begin
        a :=300;
        n := 500;
        v_tot:=a+n;
        dbms_output.put_line('the sum of two numbers a,n is:'||v_tot);
      end; 
dbms_output.put_line('the value a is:'||a);
end;



declare
a number;
b number;
c number;
begin
a:=200;
b:=500;
c:=b-a;
dbms_output.put_line('the subtraction of values are:'||c);
end;

commit;


declare
m number;
n number;
begin
m:=1000;
dbms_output.put_line('the m value is:'||m);
    declare
     n number;
    i number;
    begin
    m:=100;
    n:=200;
    i:=m*n;
    dbms_output.put_line('the multiplication of two numbers is m,n is:'||i);
    end;
dbms_output.put_line('the outer value is:'||m);
end;


declare
m number;
n number;
begin
m:=1000;
    declare
     n number;
    i number;
--m number;
    begin
    m:=100;
    n:=200;
    i:=m*n;
    dbms_output.put_line('the multiplication od two numbers is m,n is:'||i);
    end;
dbms_output.put_line('the outer value is:'||s);
end;


set serveroutput on

declare
a number:=2;
begin
declare
c number:=10;
begin
dbms_output.put_line('the value is:' || a||c);
end;
end;


commit


create table marks(std_id number(5),mt number(10),me number(10),mm number(10),mh number(10),ms 
number(10),mss number(10));

insert into marks values(&std_id,&mt,&me,&mm,&mh,&ms,&mss);

set serveroutput on
declare
v_num number;
v1_num number;
v2_num number;
v3_num number;
v4_num number;
begin
select std_id,(mt+me+mm+mh+ms+mss) "total_marks",
	      ((mt+me+mm+mh+ms+mss)/6) "avg_marks",
	greatest(mt,me,mm,mh,ms,mss) "max_marks",
	least(mt,me,mm,mh,ms,mss) "min_marks" into v_num,v1_num,v2_num,v3_num,v4_num from marks where std_id=103;
	dbms_output.put_line('the marks of student id:'||v1_num||' '||v2_num||' '||v3_num||' '||v4_num);
end;

select *from marks



DECLARE  
i NUMBER := 1;  
BEGIN  
LOOP  
EXIT WHEN i>10;  
DBMS_OUTPUT.PUT_LINE(i);  
i := i+1;  
END LOOP;  
END;  

begin
for a in 1..10 loop
dbms_output.put_line(a);
end loop;
end;

commit;

declare
var1 number:=&var1;
begin
if mod(var1,2)=0 then
dbms_output.put_line(' 1 is even');
else
dbms_output.put_line('1 is odd');
end if;
end;




declare
 v_ename;
 v_comm;
 v_netsal;
 v_sal;
 begin
 select ename,sal,sal+nvl(comm,0) "netsal"
 into v_ename,v_sal,v_netsal,v_comm from emp where empno=&empno;
 dbms_output.put_line('the emp details :'||v_ename||' '||v_sal||' '||v_netsal||' '||v_comm);
 end;



SELECT deptno
, COUNT(*) OVER ( ) AS empcnt
FROM scott.emp
GROUP BY deptno;

SELECT DISTINCT deptno ,count(*) 
 OVER ( ) AS empcnt
FROM scott.emp;

SELECT DISTINCT deptno
, COUNT(*) OVER ( ) AS empcnt
FROM scott.emp;

SELECT deptno, ename, sal, job
, COUNT ( * ) OVER ( PARTITION BY job ) jobcount
, SUM ( sal ) OVER ( PARTITION BY deptno ) deptsum
from scott.emp;

SELECT deptno, ename, hiredate
, LAG ( ename ) OVER ( ORDER BY hiredate ) prior_hire
FROM scott.emp
ORDER BY deptno, ename;


SELECT empno,
       ename,
       job,
       sal,
       LEAD(sal, 1, 0) OVER (ORDER BY sal) AS sal_next
       --LEAD(sal, 1, 0) OVER (ORDER BY sal) - sal AS sal_diff
FROM   emp;



SELECT deptno, ename, sal
, LAG ( ename ) OVER ( ORDER BY ename ) f1
, LAG ( ename , 2 ) OVER ( ORDER BY ename ) f2
, LEAD ( ename ) OVER ( ORDER BY ename DESC) f3
, LAG ( sal ) OVER ( ORDER BY ename ) f4
FROM scott.emp
ORDER BY deptno, ename;


select deptno,ename,sal,lag(sal) over(order by sal DESC) f from scott.emp

SELECT deptno, empno, ename, sal,job
, MIN ( sal ) OVER (PARTITION BY deptno,JOB ) minsal
FROM scott.emp;


SELECT deptno, ename, sal
, RANK ( ) OVER ( ORDER BY ename ) f1 
, DENSE_RANK ( ) OVER ( ORDER BY ename ) f2
, ROW_NUMBER ( ) OVER ( ORDER BY ename ) f3
FROM scott.emp
ORDER BY deptno, sal;

select deptno,sal,ename,job,rank() over (order by sal) f1 from emp
select deptno,sal,ename,job,dense_rank() over (order by sal) f1 from emp
select deptno,sal,ename,job,row_number() over (order by ename) f1 from emp

SELECT deptno, ename, job, sal, hiredate
, ROW_NUMBER ( ) OVER ( ORDER BY sal DESC) r1 from emp

SELECT deptno, ename, sal
, SUM ( sal ) OVER ( ORDER BY ename ) s
, COUNT ( * ) OVER ( ORDER BY ename ) c
, MIN ( sal ) OVER ( ORDER BY ename ) mn
, MAX ( sal ) OVER ( ORDER BY ename ) mx
FROM scott.emp
WHERE deptno = 10;


Select count(*) over (order by hiredate asc range 50 preceding) from emp;

SELECT empno, ename, hiredate
, COUNT(*) OVER ( ORDER BY hiredate

RANGE BETWEEN INTERVAL '6' MONTH PRECEDING

AND INTERVAL '6' MONTH FOLLOWING ) AS six_months from emp

select deptno,ename,hiredate,count(*) 
over (order by hiredate range between interval '1' month preceding and interval '1' month following) as six_months from scott.emp;

select hiredate,sum(sal) over
(order by hiredate range between interval '6' month preceding and interval '6' month following) as six_months from emp;

select sum(sal) from emp where hiredate='17-dec-80';



set serveroutput on

declare
s varchar2(5):='s';
begin
if lower(s) in ('a','e','i','o','u') then
dbms_output.put_line('a is vowel');
else
dbms_output.put_line('s is not a vowel');
end if;
end;

................

declare
n number:=10;
m number:=30;
begin
dbms_output.put_line('starts the value');
    if (n=m) then 
    dbms_output.put_line('n is not correct');
        elsif(n!=m) then
        dbms_output.put_line('n is correct');
            elsif(n<m) then
            dbms_output.put_line('n is lower value');
                elsif(n>m) then
                dbms_output.put_line('n is highest value');
                else
                dbms_output.put_line('n is unknown');
                end if;
end;

set serveroutput on

declare
a number(3):=300;
b number(3):=300;
begin
--dbms_output.put_line('program starts in:');
if(a=b) then
dbms_output.put_line('a is correct');
    if(a<=b) then
    dbms_output.put_line('a is equal');
        if(a>b) then
        dbms_output.put_line('a is greater value');
            if(a!=b) then
            dbms_output.put_line('a is not equal value');
                if(b<a) then
                dbms_output.put_line('b is correct value');
                end if;
            end if;
        end if;
    end if;
end if;
dbms_output.put_line('invalid value');
end;

commit

DECLARE 
   a number(2) := 15; 
BEGIN 
   WHILE a<20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
      a := a + 1; 
   END LOOP; 
END; 
/ 

declare
i number(2);
j number(2);
begin
i:=2;
loop
    j:=2;
    loop
    exit when (mod(i,j)=0) or  (j=i);
    j:=j+1;
    end loop;
IF (j = i ) THEN 
      dbms_output.put_line(i || ' is prime'); 
   END IF; 
   i := i + 1; 
   exit WHEN i = 50; 
   END LOOP; 
END; 

commit



set serveroutput on
declare



 create materialized view emp_dno enable query rewrite as select deptno,sum(sal),count(empno) fr
om emp group by deptno;



create materialized view emp_dept_count
    as 
    select dname,job,count(*) from emp e,dept d
    where e.deptno=d.deptno
    group by dname,job;


select *from emp_dept_coun

update emp set sal=1000 where ename='SMITH'
select *from emp

select *from emp_dept_count

CREATE or replace MATERIALIZED VIEW T
REFRESH 
START WITH SYSDATE
NEXT SYSDATE + 1
AS SELECT *from scott.emp

commit


set serveroutput on
declare
n number:=10;
begin
--dbms_output.put_line('program starts now');
    loop
   dbms_output.put_line('n value prints:'||n);
    n:=n+1;
    if n<=10 then
     raise_application_error
            (-20000,'it will show');
    end if;
    end loop;
end;

declare


declare
n number(2):=2;
sum number(2):=0;
begin
while n<=10 
    loop
        dbms_output.put_line('the even number is:'||n);
        sum:=sum+n;
        n:=n+2;
    end loop;
dbms_output.put_line('the sum of even numbers are:'||sum);
end;



DECLARE
    num NUMBER(3) := 2; 
    sum1 NUMBER(4) := 0; 
BEGIN
    WHILE num <= 5 LOOP     
        dbms_output.Put_line(num);
        sum1 := sum1 + num; 
         num := num + 2; 
        END LOOP; 
      dbms_output.Put_line('Sum of even numbers is ' || sum1); 
END; 

declare
num1 number(10);
sum1 number(5);
begin
num1:=3;
sum1:=1;
while num1<=10 loop
    dbms_output.put_line(num1);
    sum1:=sum1+num1;
    end loop;
    dbms_output.put_line('sum of odd numbers are:'||sum1);
end;


declare
n number:=2;
s number:=0;
begin
  loop
     dbms_output.put_line(n);
      n:=n+2;
   s:=s+n;
    exit when n>=10;
    end loop;
dbms_output.put_line(s);
end;


declare
n number:=2;
s number:=0;
begin
  while n<=10 loop
     dbms_output.put_line(n);
      n:=n+2;
   s:=s+n;
    end loop;
dbms_output.put_line(s);
end;



declare
a varchar2(10):='&a';
b varchar2(10):='&b';
c varchar2(10);
begin
dbms_output.put_line('before');
dbms_output.put_line('a= '||a||' ,' ||'b= '||b);
c:=a;
a:=b;
b:=c;
dbms_output.put_line('after');
dbms_output.put_line('a= '||a||' ,' ||'b= '||b);
end;

commit

*********** how to swap two numbers without using third variable.




set serveroutput on
declare
v_exp number(2);
v_hike number(5,2);
v_sal number;
begin
select floor((sysdate-hiredate) / 365 ),sal into v_exp,v_sal
from emp where empno=7369;
if (v_exp>10) then
    v_hike:=1.20;
     dbms_output.put_line('the hike of emp'||v_sal*v_hike);
    elsif (v_exp>5) then
        v_hike:=1.10;
         dbms_output.put_line('the hike of emp'||v_sal*v_hike);
        else
        v_hike:=1.05;
         dbms_output.put_line('the hike of emp'||v_sal*v_hike);
        end if;
 end;

select sysdate-hiredate/365 from emp where 

select sal,hiredate from emp where empno=7369

update emp set sal=800 where ename='SMITH'

commit

set serveroutput on
declare
v_employeeid employees.employee_id%type := :sv_employeeid;
v_hiredate employees.hire_date%type ;
v_exp number;
begin
select hire_date into v_hiredate from employees where employee_id=v_employeeid;
v_exp := round((months_between(sysdate,v_hiredate)/12),3);
DBMS_OUTPUT.PUT_LINE('employees experience is '||v_exp||'in years');
end;


select round((months_between(sysdate,hiredate)/12),3) from emp where ename='SMITH'


declare
    odd number:=0;
    even number:=0;
    i number;
    begin
    for i in 1..100
    loop
    if(i mod 2=0) then
    even:=even+i;
   else
   odd:=odd+i;
   end if;
   end loop;
   dbms_output.put_line('the sum of 100 even no is'||even);
   dbms_output.put_line('the sum of 100 odd no is'||odd);
   end;
   /
   
   declare
   i emp.sal%type;
   n emp.ename%type;
   begin
   select sal,ename into i,n from emp where empno=&empno;
   dbms_output.put_line(i||' '||n);
   end;
   
     
   declare
   a number:=&a;
   b number:=&b;
   begin
    a:=a+b;
   b:=a-b;
   a:=a-b;
   
     dbms_output.put_line(a||' '||b);
end;


declare
i emp%rowtype;
begin
select ename,sal,job into i.ename,i.sal,i.job from emp where empno=&empno;
dbms_output.put_line(i.ename||' '||i.sal||' '||i.job);
end;

commit
select *from emp


*********** PRIME NUMBER ***********

set serveroutput on
declare
n number:=10;
i number:=2;
temp number:=1;
begin
for i in 2..n/2
loop
 if mod(n,i)=0 then
 temp:=0;
 exit;
 end if;
 end loop;
 if temp=0 then
 dbms_output.put_line('true');
  end if;
 end;
 
 
    declare
    n number; 
    m number; 
    temp number:=0; 
    rem number; 
   begin
    n:=5432112345; 
    m:=n; 
     while n>0 
    loop 
        rem:=mod(n,10); 
        temp:=(temp*10)+rem; 
        n:=trunc(n/10); 
    end loop; 
      if m = temp
    then
        dbms_output.put_line('true'); 
    else
        dbms_output.put_line('false'); 
    end if; 
end; 
/ 
  
  
declare 
n number := 1; 
begin 
while n<=10 
loop 
dbms_output.put_line(n); 
n := n+2; 
end loop; 
end;
/



declare
n number:=1;
--s number:=0;
begin
  loop
     dbms_output.put_line(n);
      n:=n+2;
   --s:=s+n;
    exit when n>=10;
    end loop;
--dbms_output.put_line(s);
end;


declare
n number:=&n;
begin
if mod(n,2)=1 then
dbms_output.put_line('the no is odd');
else
dbms_output.put_line('the no is even');

--n:=n+2;
end if;
end;

  
   

DECLARE
    i NUMBER;
    counter NUMBER;
    n NUMBER;
    k NUMBER;
BEGIN
    i := 2;
    counter := 0;
    n := 50;
    k := n/2;
    FOR i IN 1..k LOOP
        IF (n%i := 0 ) THEN
            counter := 1;
        END IF;
        IF (counter := 0) THEN
            DBMS_OUTPUT.PUT_LINE(n||' is prime number');
        END IF;
    END LOOP;
END;


declare
fac number:=1;
n number:=&n;
begin
while n>0
loop
fac:=n*fac;
n:=n-1;
end loop;
dbms_output.put_line(fac);
end;

declare
fac number:=1;
n number:=&n;
begin
for i in 1..5
loop
fac:=n*fac;
n:=n-1;
end loop;
uma(fac);
end;

variable g number;
set serveroutput on
declare
a number:=10;
begin
:g:=a+1;
end;

print g

declare
cursor c1 is select ename,sal from emp;
v_ename varchar2(20);
v_sal number(20);
begin
    if not c1%isopen then
    open c1;
    end if;
fetch c1 into v_ename,v_sal;
while c1%found
loop
fetch c1 into v_ename,v_sal;
loop
fetch c1 into v_ename,v_sal;
exit when c1%notfound;
exit when c1%rowcount>5;
dbms_output.put_line( rpad(v_ename,10,' ') || v_sal|| ' ' ||c1%rowcount|| rpad(' ',10));
end loop;
end loop;
close c1;
end;

commit


DECLARE  
-- declare variables for data fetched from cursors
  empid      employees.employee_id%TYPE; -- variable for employee_id
  jobid      employees.job_id%TYPE;      -- variable for job_id
  lastname   employees.last_name%TYPE;   -- variable for last_name
  rowcount   NUMBER;
-- declare the cursors
  CURSOR cursor1 IS SELECT last_name, job_id FROM employees 
                 WHERE job_id LIKE '%CLERK';
  CURSOR cursor2 is SELECT employee_id, last_name, job_id FROM employees 
                 WHERE job_id LIKE '%MAN' OR job_id LIKE '%MGR';
BEGIN
-- start the processing with cursor1
  OPEN cursor1; -- open cursor1 before fetching
  DBMS_OUTPUT.PUT_LINE( '---------- cursor 1-----------------' );
  LOOP
    FETCH cursor1 INTO lastname, jobid; -- fetches 2 columns into variables
-- check the cursor attribute NOTFOUND for the end of data
    EXIT WHEN cursor1%NOTFOUND;
-- display the last name and job ID for each record (row) fetched
    DBMS_OUTPUT.PUT_LINE( RPAD(lastname, 25, ' ') || jobid );
  END LOOP;
  rowcount := cursor1%ROWCOUNT;
  DBMS_OUTPUT.PUT_LINE('The number of rows fetched is ' || rowcount );
  CLOSE cursor1;

-- start the processing with cursor2
  OPEN cursor2;
  DBMS_OUTPUT.PUT_LINE( '---------- cursor 2-----------------' );
  LOOP
-- fetch 3 columns into the variables
    FETCH cursor2 INTO empid, lastname, jobid; 
    EXIT WHEN cursor2%NOTFOUND;
-- display the employee ID, last name, and job ID for each record (row) fetched
    DBMS_OUTPUT.PUT_LINE( empid || ': ' || RPAD(lastname, 25, ' ') || jobid );
  END LOOP;
  rowcount := cursor2%ROWCOUNT;
  DBMS_OUTPUT.PUT_LINE('The number of rows fetched is ' || rowcount );
  CLOSE cursor2;
END;
/


declare
v_ename emp.ename%type;
v_deptno emp.deptno%type;
cursor c1 is select ename from emp;
cursor c2 is select deptno from emp;
rowcount number;
begin
    if not c1%isopen then
    open c1;
    end if;
    loop
fetch c1 into v_ename;
    exit when c1%notfound;
    uma(v_ename);
    end loop;
rowcount:=c1%rowcount;
uma('the number of employees are:'|| rowcount);
close c1;
    open c2;
    fetch c2 into v_deptno; 
    while c2%found 
    loop
        fetch c2 into v_deptno; 
    uma(v_deptno);
    end loop;
close c2;
end;

commit

select *from employees
declare
v_first_name employees.first_name%type;
begin
select first_name into v_first_name from employees where first_name='Steven';
dbms_outputlname);
exception when too_many_rows then
uma('more than two numbers ');
end;


declare
v_ename varchar2(20);
begin
select ename into v_ename from emp where sal=3000;
uma(v_ename);
exception when too_many_rows then
uma('the more than two numbers ');
end;

declare
v_ename emp.ename%type;
begin
select ename into v_ename from emp where ename='uma';
uma(v_ename);
exception when no_data_found then
uma('no data exists in a table');
end;


commit

declare
cursor c1 is select ename from emp;
v_ename emp.ename%type;
begin
open c1;
fetch c1 into v_ename;
uma(v_ename);
open c1;
exception when cursor_already_open then
uma('cursor already open baby');
close c1;
end;

commit

declare
cursor c1 is select sal from emp;
v_sal emp.sal%type;
begin
fetch c1 into v_sal;
uma(v_sal);
close c1;
exception
when invalid_cursor then
uma('not open a cursor better to open a cursor');
end;

commit

begin
insert into emp(empno,sal) values(1,'devi');
exception 
when invalid_number then
uma('invalid string type');
end;

set serveroutput on
declare
u exception;
begin
if to_char(sysdate,'dy')='mon' then
raise u;
end if;
when u then
uma('my exception raised today');
end;


declare
cursor c1(p_deptno number) is select *from emp where deptno=p_deptno;
i emp%rowtype;
begin
open c1(20);
loop
fetch c1 into i;
exit when c1%notfound;
uma(i.ename|| ' '|| i.deptno||' '||i.job);
end loop;
open c1(30);
exception when cursor_already_open then
uma('its alreday open');
close c1;
end;

declare
cursor c1 is select * from emp;
rowcount number;
begin
for i in c1
loop
uma(i.ename||' '||i.sal||' '||i.deptno);
--uma('the employees count:'|| rowcount);
end loop;
end;


begin
for i in (select *from emp)
loop
uma(i.ename||' '||i.sal);
end loop;
end;
************ PARAMETRIZED CURSORS **************
declare
cursor c1(p_job varchar2) is select * from emp where job=p_job;
i emp%rowtype;
begin
open c1('MANAGER');
uma('the manager name is:');
loop
fetch c1 into i;
exit when c1%notfound;
uma(i.ename);
end loop;
close c1;
open c1('ANALYST');
loop
fetch c1 into i;
exit when c1%notfound;
uma(i.ename);
end loop;
close c1;
end;

commit




------------------------------------------------------------------------------------------------------------------------------------------


select *from tab;
create table student(sid number(4) primary key,
                    sname varchar2(10),
                    loc varchar2(10),
                    dob date,
                    age number(2) check(age>21),
                    cid number(2));
desc student;
commit;
alter table student add doj date;
create table course(cid number(3) primary key,
                    cname varchar2(10),
                    faculty_id number(2) 
                    constraint fk_course REFERENCES student(sid));
    alter table course add constraint pk_course primary key(cid);
desc course;
alter table course add constraint pk_course primary key(cname);
commit;
r table course drop constraint fk_faculty_id;
select *from course;
select *from student;
desc student;
create table course(cid number(3) primary key,
                    cname varchar2(10),
                    faculty_id number(2),
                    foreign key(cid) references student(sid));

select column_name,constraint_name from user_cons_columns where table_name='COURSE';


select ename,job,hiredate,deptno ,case when deptno=20 then 'ACCOUNTING'
                                when deptno=10 and job='MANAGER' then 'SALES'
                               else  ename end from emp; 



  select constraint_name,constraint_type from user_constraints where table_name='STUDENT';
 drop table course;
 
 create table course(cid number(4) primary key,
                        cname varchar2(10),
                        faculty_id number(2));
alter table student add foreign key(cid) references course(cid);
                        
                        
    desc student;   
    commit;
insert into student values(101,'umadevi','pune','10-sep-1991',24,10,'07-sep-2016');   

insert into course values(10,'MCA',1);
insert into course values(50,'EEE',5);

select *from course;
select *from student;
insert into student values(&sid,'&sname','&loc','&dob',&age,&cid,'&doj');
commit;
select s.sname,c.cname,s.sid,s.age,s.loc from student s inner join course c on (s.cid=c.cid);

select *from student;

create table emp2 as select *from emp;
create table x  as select *from emp;
select *from x;
truncate table emp2;
desc emp2;
alter table emp2 alter column sal varchar2(10);
alter table emp2 modify sal varchar2(10);
desc emp2;
insert into emp2 select *from x;
select *from emp2;
insert into emp2 values(2221,'UMA','CLERK',6653,'12-SEP-22','S120',120,10);
select s.sname,c.cname from student s,course c where s.cid=c.cid and c.cname in('MCA','ECE')order by c.cname;

roll back;
select *from emp;
select CONVERT(varchar2(9),getdate()) as result;
select CONVERT(VARCHAR(10),GETDATE(),3)"RESULTL";
COMMIT;
....................................................
select substr(ename,1,3) from emp;
select initcap(substr(ename,1,6)) "employee",length(ename) from emp where length(ename)<>6 and deptno=20;
select initcap(lower(substr(ename,1,4))) "employee",length(ename)from emp where deptno=30;

select substr('ksheerasagare jaya praveen',1,instr('ksheerasagare jaya praveen',' ')-1)
"first name" , substr('ksheerasagare jaya praveen',instr('ksheerasagare jaya praveen',' ',1,2)+1) 
"last name" from dual;


select substr('ksheerasagare jaya praveen',1,instr('ksheerasagare jaya praveen',' ',1,1))
"first name" from dual;

select substr('ksheerasagare jaya praveen',instr('ksheerasagare jaya praveen',' ',1,2))
"last name" from dual;

select (instr('ksheerasagare jaya praveen',' ',1,2)-instr('ksheerasagare jaya praveen',' ',1,1)) from dual;


select substr('siva rama krishna',1,instr('siva rama krishna',' ',1,1)-1) "first name" ,
substr('siva rama krishna',instr('siva rama krishna',' ',1,1),
(instr('siva rama krishna',' ',1,2)
-instr('siva rama krishna',' ',1,1))) "middle name",
substr('siva rama krishna',instr('siva rama krishna',' ',1,2)+1)"last name" from dual;
commit;


select substr('lavanya sri janu',instr('lavanya sri janu',' ',1,1),instr('lavanya sri janu',' ',1,2)-(instr('lavanya sri janu',' ',1,1))) "middle name" from dual


select substr('siva rama krishna',instr('siva rama krishna',' ',1,1),
(instr('siva rama krishna',' ',1,2)
-instr('siva rama krishna',' ',1,1))) "middle name" from dual;

select substr('siva rama krishna',instr('siva rama krishna',' ',1,2)+1) "last name" from dual;

select ename||' '||q'(designation'S)'||' '||initcap(job)||' '||'joining date is'||' '||hiredate from emp;

select to_char(sysdate,'yy/mon/dd') from dual;
select to_char(sysdate,'yyy/month/dd') from dual;
select to_char(sysdate,'yy/mm/dd') from dual;
select last_day(sysdate,'wed') from dual;
select now();

select deptno, decode(deptno,10,'ACCOUNTING',
                    20,'SALES',
                    30,'REASERCH')"result"  group by deptno from emp;
select round(sysdate,yyyy)from dual;

select sysdate from dual;
select to_char(sysdate,'month') from dual;
select to_char(sysdate,'dd') from dual;
select last_day(sysdate)+1 from dual;
select last_day(sysdate)-2 from dual;
select last_day(hiredate)-2 from emp;
select next_day(hiredate,'day') from emp;
select round(to_date('01-jul-14'),'year') as new_year from dual;
select (sysdate+5/1440) from dual;
select sysdate + (5/1440) as five_mintues_from_now
from dual

commit;

select trunc(sysdate,'day') from dual;

select trunc(sysdate,'month') from dual;
select round(sysdate,'year') from dual;
select upper(ename) from emp where ename='SMITH' and job='CLERK';
select deptno,sum(sal) as total_sal from emp group by deptno order by deptno;
select sum(sal) from emp group by deptno;

SELECT * FROM EMP WHERE DEPTNO!=ALL(10,NULL,20);

SELECT * FROM EMP WHERE DEPTNO=ANY(10,NULL,20);
select deptno,sum (sal)"tot_sal" from emp group by deptno;
select sum(sal+nvl(comm,0)) as tot_sal from emp where deptno=20;
select deptno,sum(sal) from emp group by deptno;
select *from emp;
select sum(sal) from emp where deptno=20;

\select sum(sal+nvl(comm,0)) "totsal" from emp group by deptno;

45.select deptno,max(sal) from emp group by deptno;

46.select job,sum(sal) "salary" from emp group by job;

47.select job,min(sal) from emp group by job;

48.select deptno,count(*) from emp group by deptno having count(*)>5;

49.select job,sum(sal) "totsal" from emp group by job having sum(sal)>4000; 

50.select job,count(*) "tot employees" from emp group by job having count(*)>3;

51.select ename,sal from emp where sal=(select max(sal) from emp);

52.select empno,ename,job,sal from emp where job='CLERK' and sal=(select max(sal) from emp where job='CLERK');

53.select ename,job,sal from emp where job='SALESMAN' and sal>(select max(sal) from emp where job='CLERK');

54. select ename,job,sal from emp where job='CLERK' and sal>(select min(sal)from emp where job='SALESMAN');
 
 select *from emp where sal in(select distinct top 5 sal from emp )order by sal desc;
 select *from emp e inner join dept d on e.deptno=d.deptno and comm>12/100;
 
  select *from emp e inner join dept d on e.deptno=d.deptno and comm>12/100 and e.sal<>1600;

create table num(no number(3),doj date);
desc num;
insert into num values(&no,'&doj');
select *from num;
***************doubt*******.................
select case   when length(no)=1 then concat('0',no)
              when length(no)=2 then concat(no,'')
               else null end as value from num order by no
               *********************************

               
select sal,deptno,job,
                case when deptno=10 and job='MANAGER' then  sal+200
                 when deptno=10 then sal+100
                    else null end as value  from emp;


55.select ename from emp where sal > ANY(select sal from emp where ename in('JONES','SCOTT'));

56.select job from emp e where sal=(select max(sal) from emp e , dept d where e.deptno=d.deptno)
 
57.select ename from emp e where sal=(select max(sal) from emp where e.job=job)
                    (or)
   select ename from emp where (job,sal) 
            in(select job,max(sal) from emp group by job)

select *from emp;
58.select ename from emp where deptno=(select deptno from dept where dname='ACCOUNTING');
                        (or)     
    select e.ename,d.dname from emp e inner join dept d on(e.deptno=d.deptno) and d.dname='ACCOUNTING'

59.select ename from emp where deptno=(select deptno from dept where loc='CHICAGO')
                        (or)
    select e.ename,d.dname,loc from emp e,dept d where e.deptno=d.deptno and loc='CHICAGO';

60.select job,sum(sal) from emp group by job having sum(sal)>(select max(sal) from emp where job='MANAGER')

61.select ename ,deptno,sal from emp where deptno=10 and sal> ANY(select deptno from dept where deptno in(20,30)) 

62.select ename from emp where deptno=10 and sal> ALL(select sal from emp where deptno in(20,30))

63.select upper(ename)from emp;

64.select lower(ename) from emp;

65.select initcap(ename) from emp;

66.select length('umadevi') from dual;

67.select length(ename)from emp

68.select ename||empno from emp OR select concat(ename,empno) from emp

69.



    select translate('umadevi','umadevi','ramakrish') from dual;

select translate('umadevi is a good girl','umadevi','ramkris') from dual;

select lpad(' ',rownum+1,'*')||ename as employees_name from emp


select lpad(' ',rownum+1,'*')||job from emp

70.select instr('computer maintenance corporation','a',1,2) no from dual;

71.select translate('Alliens','a','B') from dual;

72.select empno,ename,hiredate,sal,deptno, REPLACE(job,'MANAGER','BOSS') job from emp

73.select empno,ename,decode(deptno,10,'ACCOUNTING',
                                         20,'SALES',
                                        30,'RESEARCH') deptno from emp;
                                        
74.select round(sysdate-to_date('28-feb-1991')) "age in days" from dual; 

      
75.select round(months_between(sysdate,'28-feb-1991')) "months" from dual;

76.select to_char('15th August Friday Nienteen Nienty Seven') "current date"  from dual;

79.select next_day(sysdate,'saturday') from dual;

80.select current_date from dual; OR select sysdate from dual;
commit:


select *from emp where exists(select 15 from emp);
select *from emp where exists(select 1 from emp where 2=2)
select *from emp where exists(select *from dept)
select *from emp where not exists(select *from dept where 1=2)
commit;


SELECT sal FROM (
    SELECT sal, row_number() OVER (order by sal desc) AS rn FROM emp
)
WHERE rn = 2


select ename,sal from emp e where 1-1=(select count(distinct sal) from emp e1 where e1.sal>e.sal);
select ename,empno,deptno,sal from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>=e.sal) 

81.select add_months(sysdate,-3) from dual;

82.select deptno from emp where deptno=10 
intersect
select deptno from dept where deptno=20;

83.select deptno from emp where deptno=10
union 
select deptno from emp where deptno=20        

select *from emp where deptno=10 and job in(select job from emp where deptno=20)

select *from (select *from (select *from emp))

84.select distinct(job) from emp where deptno=10;

select deptno,dname from dept where deptno not in(select distinct(deptno) from emp)

select *from emp where deptno not in(select job from emp where job='MANAGER')

85.select empno,job,ename from emp where empno not in(select mgr from emp where mgr is not null) 

86.select *from emp e,dept d,salgrade s where e.deptno=d.deptno and d.dname='SALES' 
and e.sal between losal and hisal and s.grade=3

select *from emp;

select ename,sal,job,empno from emp where empno not in(select nvl(mgr,0) from emp)

87.select *from emp where job<>'MANAGER';
                    
select empno,ename,sal from emp where sal>ANY(select sal from emp where deptno=10)order by ename;
select sal from emp where deptno=10;
select *from emp where sal>(select max(sal) from emp where deptno=10)
select empno,ename,job,sal from emp where deptno=30 and exists(select count(*) 
from emp where deptno=30 
and job='ANALYST' having count(*)>=3);

88. select ename from emp where length(ename)>4

89. select dname,loc from dept where dname like'S%' or loc like'%K'

90. select e.ename,m.ename from emp e  inner join emp m on(m.empno=e.mgr) where m.ename='JONES';

92.select *from emp e inner join dept d on e.deptno=d.deptno

91.select ename,sal from emp where sal*1.20>3000 
                (OR)
    select *from emp where empno in(select empno from emp where (sal+sal*20/100)>3000)

93.select ename,deptno from emp where deptno in(select deptno from dept where dname='SALES')

94.select e.ename,d.dname,sal,comm,loc from emp e inner join dept d on(e.deptno=d.deptno) where e.sal
between 2000 and 5000 and loc='CHICAGO';

95.select * from emp e,emp m where e.mgr=m.empno and e.sal>m.sal

    select *from emp e where e.sal>(select m.sal from emp m where m.empno=e.mgr)

96.select distinct m.ename from emp e,emp m where e.mgr=m.empno and e.deptno=m.deptno

 select *from emp e where deptno=(select m.deptno from emp m where e.mgr=m.empno)

select  * from emp 
cross join dept


select *from emp order by comm;
select *from emp order by comm desc
select *from emp order by empno 
 select ename,select deptno,select sal,select hiredate from emp;
 select *from emp where empno not in(select nvl(mgr,0) from emp)
 select *from emp where empno not in(select distinct mgr from emp where mgr is not null)
 
 select *from emp where rownum<=5;
 
 select *from emp 
 minus
 select *from emp where rownum<=(select count(*)-(9) from emp);
 minus
select * from  emp
 minus
 select * from emp where rownum<=(select count(*)-(5) from emp);
 
 ***************First five records*************
  select *from emp where rownum<=(select count(*)-(9) from emp)
  
  *********** last five records*********
 select * from  emp
 minus
 select * from emp where rownum<=(select count(*)-(5) from emp);
 *************************************************
 
.......................department wise maximum of sum of salries...............

select deptno,sum(sal) from emp group by deptno having sum(sal)=
(select max(sum(sal)) from emp group by deptno)
............................

select * from emp
where  exists (select * from dept);
select * from emp 
where exists (select * from emp where 3=3);

select * from emp e
where exists(select * from emp e1 where e1.mgr=e.empno);

select * from emp e
where exists (select * from dept d where d.deptno=e.deptno);

*** *********display 3rd highest salary*****

select * from emp e where 3=(select count(distinct sal) from emp e1 where e1.sal>=e.sal);

select *from emp e where 2=(select count(distinct sal)from emp e1 where e1.sal>=e.sal);
...............................................................

>>>>>>>>>>> >>>>>>   display managers names  >>>>>>>>> 

select e.ename "managers_name" from emp e where exists(select *from emp e1 where e1.mgr=e.empno) 
            OR
select distinct m.ename from emp e, emp m where e.mgr=m.empno
            OR
select ename from emp where empno in(select mgr from emp)   

*****************************************************************************************

************display the details of employees who are getting highest sal of "BLAKE"  ***********  
     
select *from emp where sal>(select sal from emp where ename='BLAKE')

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
........... how to get second record.........

select *from emp where rownum<3 
minus
select *from emp where rownum<2
...........................................    
    
    select *from emp e where &n=(select count(distinct sal) from emp e1 where e1.sal>=e.sal)
    
      select REGEXP_SUBSTR('test1 test2 test3', '[^ ]+', 1, 2) from dual;
select max(sal) from(select sal from emp);
select max(sal) from(select sal from emp)

select substr(ltrim('pittu uma devi',substr('pittu uma devi',1,5)),2,3) from dual;
 
     
select empno,avg(sal),count(comm) from dept join emp using(deptno) group by empno;

select e.ename, d.dname,loc from emp e join dept d on d.deptno=20

select ename,hiredate from emp where to_char(hiredate,'yyyy')=1982;
select ename,to_date(hiredate,'DD-MM-YY') from emp;

commit;

select sal,ltrim(ename,'B') from emp where empno=7698;

select *from tab;
drop table grade_type;
 SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = "INSTRUCTOR";
 
+++++++++ doubt+++++++++++++select ename,empno from emp where decode (deptno, 20,'ACCOUNTING',
                                                30,'SALES',
                                                40,'RESEARCH','OPERATIONS');
                                                
*****************2nd exam questions and answers::::::::::::::

1. Write a SELECT statement that lists the last names of students living in either zip code 10048, 11102, or 11209.

select last_name,zip  from student where zip in(10048,11102,11209)        or

select last_name ,zip from student where zip=10048 or zip=11102 or zip=11209
                                                
2. Write a SELECT statement that lists the first and last names of instructors with the letter i 
(either uppercase or lowercase) in their last name, living in zip code 10025.
   
   select first_name||' '||last_name from instructor where upper(last_name) like '%I%' or lower(last_name) like '%i%' and zip=10025
   
   select first_name||' '||last_name from instructor where lower(last_name) like'%i%' and zip=10025
    
3. Write a SELECT statement that lists descriptions of courses for which there are prerequisites 
and that cost less than 1100.
 
    select description,cost,prerequisite from course where prerequisite is not null and cost < 1100
 
 4. Show the salutation, first name, and last name of students with the last name Grant. 
Order the result by salutation in descending order and by first name in ascending order.

    select salutation,first_name,last_name from student where last_name= 'Grant' order by salutation desc,first_name                                       
                                                
 5. Write a SQL statement to retrieve students who have a last name with the lowercase letter o 
occurring three or more times. 

   doubt ///////////////select student_id,last_name from student where instr(last_name,'o',1,3)> 2;
                                                
6.     Using functions in the SELECT list and WHERE and ORDER BY clauses, write a SELECT statement that 
returns course numbers and course descriptions from the COURSE table and looks like the following result set. 
Use the SQL Developer Run Script icon to display the result in fixed-width format.
Description
204.......Intro to SQL
130.......Intro to Unix
25........Intro to Programming
230.......Intro to the Internet
120.......Intro to Java Programming
240.......Intro to the BASIC Language
20........Intro to Information Systems
                                         
    select rpad(course_no,10,'.')||' '||description from course                                       
                                                
 7.  List the last names, first names, and phone numbers of students who do not have phone numbers. 
Display 212-555-1212 for the phone number.

  select last_name,first_name,phone "mobile",nvl2(phone,'0','212-555-1212') "contact_number"  from student                                         

    select last_name,first_name,phone "mobile",nvl(phone,'212-555-1212') "contact_number"  from student                                            
                                                
 8. Write a SELECT statement that determines the total number of students enrolled. 
Count each student only once, no matter how many courses the student is enrolled in.
                                               
         select count(distinct student_id) from enrollment                                        
                                                
9. Determine the average cost for all courses. If the course cost contains a null value, substitute the value 0.
          
          select avg(nvl(cost,0)) from course                
          
10. Write a SELECT statement that determines the date of the most recent enrollment.     

    select max(enroll_date) from enrollment
    
11. Show a list of prerequisites and count how many times each appears in the COURSE table. 
Order the result by the PREREQUISITE column.

    select prerequisite,count(*) from course group by prerequisite order by prerequisite

12. Show all the different companies for which students work. Display only companies in 
which more than four students are employed.

   select employer,count(*) from student group by employer having count(*)>4;

13. Select the course description, section number, and location for sections meeting in location L211.
    
    select c.description,s.section_no,s.location from course c inner join section s on c.course_no=s.course_no and location='L211';

14. Show the course description, section number, starting date and time of the courses Joseph German is taking.

 select c.description,s.section_id,s.start_date_time from course c,section s,enrollment e,student st where
    c.course_no=s.course_no and
    s.section_id=e.section_id and
    st.student_id=e.student_id and 
    st.first_name='Joseph' and st.last_name='German'  

15 .Using a subquery construct, determine which sections the student Henry Master is enrolled in.

    select student_id from enrollment where student_id =
    (select student_id from student where first_name='Joseph' and last_name='German')




select deptno,avg(sal) "no of dept"
from emp
where ename='SMITH'
group by deptno
having avg(sal)>10000
order by ename
commit


select *from dept

************************CASE & DECODE******************

SELECT ename, empno,
 (CASE deptno
 WHEN 10 THEN 'Accounting'
 WHEN 20 THEN 'Research'
 WHEN 30 THEN 'Sales'
 WHEN 40 THEN 'Operations'
 ELSE 'Unknown'
  END) department
FROM emp
ORDER BY ename;

select job,sal,deptno,(case when lower(ename)='allen' then 'UMA'
                                    when lower(ename)='blake' then 'SHAN'
                                    when lower(ename)='james' then 'KRISH'
                                    else 'Unknown' end) employee from emp;


select ename,sal,deptno,decode(deptno,20,'ACCOUNTING',
                                30,'SALES',
                                40,'RESEARCH',
                                deptno)department_name from emp;


select ename,job,deptno,decode(job,'CLERK','UMA',
                                    'MANAGER','KRISH',
                                    'SHAN')job_details from emp;

select *from emp where decode(deptno,10,'ACCOUNTING',
                                     20,'SALES',
                                     deptno)


commit;


************************ ROW ID, ROWNUM**************************


select rowid,rownum from dual;

select m.ename,e.mgr,count(*) "no of employees" from emp e inner join emp m on (e.mgr=m.empno) group by e.mgr,m.ename; 


SELECT uid, user FROM dual;
select e.*,rownum,rowid from emp e order by rownum

select e.*,rownum from
(select * from emp  order by sal desc) e


select e.*,rownum from
(select * from emp  order by sal desc) e
where rownum<=2;

select * from 
(select e.*,rownum rn from
(select * from emp  order by sal desc) e)
where rn=2;

select *from(select e.*,rownum rn from(select *from emp order by sal desc) e) where rn=2;

select min(sal) from (select * from (select sal from emp order by sal desc) where   rownum <=2);

select * from emp where sal=(
 select min(sal) from (select * from (select sal from emp order by sal desc) where   rownum <=2));


select *from emp where sal=
(select min(sal) from
(select *from
(select sal from emp order by sal desc) 
where rownum <=2))

select min(sal),max(sal) from emp where sal<
(select max(sal) from emp)
and
sal>(select min(sal) from emp)

select *from emp
minus
select *from emp where rownum <=(select count(*)-5 from emp)

select deptno,sum(sal) from emp group by deptno having sum(sal)=(select max(sum(sal))from  emp group by deptno);

select max(sum(sal)) from emp group by sal;


select *from emp e where 2=(select count(distinct sal) from emp e1 where e1.sal>=e.sal)


select *from emp where sal=
(select min(sal) from
(select *from 
(select sal from emp order by sal desc) 
where rownum <=2))

select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))

select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))


select rowid,e.* from emp e;


select ename,empno,mgr,job 
    from emp 
    start with job='PRESIDENT' connect by ;
    
    select ename, empno, mgr, job 
    from emp 
    start with job ='PRESIDENT' 
    connect by prior empno = mgr;
    
    
sql-ex.ru


select*from emp where sal=(select min(sal) from(select *from emp e where 2=(select count(distinct sal)from emp e1 where e1.sal>=e.sal)));

select ename,job,sal,mgr from emp connect by prior empno=mgr

select ename, empno, mgr, job 
    from emp 
    connect by prior empno = mgr;

select ename, empno, mgr, job 
    from emp 
    start with job ='PRESIDENT' 
    connect by prior empno = mgr;
    
select ename,sal,job from emp start with sal=3000 connect by prior empno=mgr;

select ename,job,sal from emp start with sal=(select max(sal) from emp) connect by prior empno=mgr
select *from tab;
select *from tab;

select *from num
select no,rowid from num 
 
 
select ename, empno, mgr, job, sal 
    from emp 
    start with sal = (select max(sal) from emp 
                               where deptno = (select deptno from dept 
                                                           where dname ='ACCOUNTING' )) 
   connect by prior empno = mgr;
   
   
commit;

   
   select ename name, connect_by_root(ename) boss 
     from emp 
     start with empno = 7839 
     connect by prior empno = mgr;
     
     
     
   *********************** INLINE VIEWS*************************
   
     
     select ename,sal,job from (select count(*) from emp ) e;
   
   select ename,job,sal,deptno from(
select * from emp where deptno=20) e;
                            
select *from(select max(sal) from emp group by deptno order by deptno) e; 

select ename,deptno
from(select *from emp where sal in(select max(sal) from emp group by deptno)order by deptno)


    select  distinct ename,sal from emp e,(select deptno,count(*) from emp e group by deptno order by deptno) 
    d,(select grade,losal,hisal from salgrade) s
    where e.deptno=d.deptno and e.sal between 3000 and 5000
    order by sal;



select distinct job,e.deptno from emp e,(select dname,deptno from dept) d where e.deptno=d.deptno

select ename,job,e.deptno from emp e,lateral(select dname,deptno from dept where e.deptno=d.deptno) d 

select st.student_id,first_name,last_name from student st ,
(select section_id,location from section) s,
(select section_id,enroll_date,student_id from enrollment) e
    where s.section_id=e.section_id and
    st.student_id=e.student_id


update (select sal from emp inne join dept using(deptno) where dname='SALES') set sal=sal+100
select *from emp

select ename from emp(select max(sal) from emp) e

CREATE TABLE STUDENT
 (STUDENT_ID NUMBER(8,0) 
 ,SALUTATION VARCHAR2(5)
 ,FIRST_NAME VARCHAR2(25)
 ,LAST_NAME VARCHAR2(25) 
 ,STREET_ADDRESS VARCHAR2(50)
 ,ZIP VARCHAR2(5) 
 ,PHONE VARCHAR2(15)
 ,EMPLOYER VARCHAR2(50)
 ,REGISTRATION_DATE DATE 
 ,CREATED_BY VARCHAR2(30) 
 ,CREATED_DATE DATE 
 ,MODIFIED_BY VARCHAR2(30) 
 ,MODIFIED_DATE DATE 
 )
/

COMMENT ON TABLE STUDENT IS 'Profile information for a student.'
/

COMMENT ON COLUMN STUDENT.STUDENT_ID IS 'The unique ID for a student.'
/

COMMENT ON COLUMN STUDENT.SALUTATION IS 'The student''s title (Ms., Mr., Dr., etc.).'
/

COMMENT ON COLUMN STUDENT.FIRST_NAME IS 'This student''s first name.'
/

COMMENT ON COLUMN STUDENT.LAST_NAME IS 'This student''s last name.'
/

COMMENT ON COLUMN STUDENT.STREET_ADDRESS IS 'The student''s street address.'
/

COMMENT ON COLUMN STUDENT.ZIP IS 'The postal zip code for this student.'
/

COMMENT ON COLUMN STUDENT.PHONE IS 'The phone number for this student including area code.'
/

COMMENT ON COLUMN STUDENT.EMPLOYER IS 'The name of the company where this student is employed.'
/

COMMENT ON COLUMN STUDENT.REGISTRATION_DATE IS 'The date this student registered in the program.'
/

COMMENT ON COLUMN STUDENT.CREATED_BY IS 'Audit column - indicates user who inserted data.'
/

COMMENT ON COLUMN STUDENT.CREATED_DATE IS 'Audit column - indicates date of insert.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_BY IS 'Audit column - indicates who made last update.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_DATE IS 'Audit column - date of last update.'
/CREATE TABLE STUDENT
 (STUDENT_ID NUMBER(8,0) 
 ,SALUTATION VARCHAR2(5)
 ,FIRST_NAME VARCHAR2(25)
 ,LAST_NAME VARCHAR2(25) 
 ,STREET_ADDRESS VARCHAR2(50)
 ,ZIP VARCHAR2(5) 
 ,PHONE VARCHAR2(15)
 ,EMPLOYER VARCHAR2(50)
 ,REGISTRATION_DATE DATE 
 ,CREATED_BY VARCHAR2(30) 
 ,CREATED_DATE DATE 
 ,MODIFIED_BY VARCHAR2(30) 
 ,MODIFIED_DATE DATE 
 )
/

COMMENT ON TABLE STUDENT IS 'Profile information for a student.'
/

COMMENT ON COLUMN STUDENT.STUDENT_ID IS 'The unique ID for a student.'
/

COMMENT ON COLUMN STUDENT.SALUTATION IS 'The student''s title (Ms., Mr., Dr., etc.).'
/

COMMENT ON COLUMN STUDENT.FIRST_NAME IS 'This student''s first name.'
/

COMMENT ON COLUMN STUDENT.LAST_NAME IS 'This student''s last name.'
/

COMMENT ON COLUMN STUDENT.STREET_ADDRESS IS 'The student''s street address.'
/

COMMENT ON COLUMN STUDENT.ZIP IS 'The postal zip code for this student.'
/

COMMENT ON COLUMN STUDENT.PHONE IS 'The phone number for this student including area code.'
/

COMMENT ON COLUMN STUDENT.EMPLOYER IS 'The name of the company where this student is employed.'
/

COMMENT ON COLUMN STUDENT.REGISTRATION_DATE IS 'The date this student registered in the program.'
/

COMMENT ON COLUMN STUDENT.CREATED_BY IS 'Audit column - indicates user who inserted data.'
/

COMMENT ON COLUMN STUDENT.CREATED_DATE IS 'Audit column - indicates date of insert.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_BY IS 'Audit column - indicates who made last update.'
/

COMMENT ON COLUMN STUDENT.MODIFIED_DATE IS 'Audit column - date of last update.'
/

select *from student

show user

select *from tab;


16.SELECT e.student_id, s.course_no,
TO_CHAR(e.enroll_date,'MM/DD/YYYY HH:MI PM')enroll,
e.section_id
FROM enrollment e JOIN section s
ON (e.section_id = s.section_id)
WHERE s.course_no = 20
AND e.enroll_date >= TO_DATE('01/30/2007','MM/DD/YYYY')
AND e.enroll_date < TO_DATE('01/31/2007','MM/DD/YYYY')  

17.
SELECT c.description, s.section_no, c.cost, s.capacity
FROM course c, section s
WHERE c.course_no = s.course_no
AND s.capacity <=
(SELECT AVG(capacity)
FROM section)
AND c.cost =	
(SELECT MIN(cost)
FROM course)

18.
SELECT course_no, SUM(capacity)
FROM section
GROUP BY course_no
HAVING SUM(capacity) <
(SELECT round(AVG(capacity))
FROM section)

19.
SELECT ROWNUM id, course_no, num_enrolled
FROM (SELECT COUNT(*) num_enrolled, s.course_no
FROM enrollment e, section s
WHERE e.section_id = s.section_id
GROUP BY s.course_no
ORDER BY 1 DESC)
WHERE ROWNUM <= 5

select rownum id,course_no from
(select count(*),s.course_no 
from enrollment e,section s 
where e.section_id=s.section_id 
group by s.course_no
order by 1 desc)where rownum<=5

20.
SELECT section_id, TO_CHAR(start_date_time, 'HH24:MI')
  FROM section
 WHERE TO_CHAR(start_date_time, 'HH24:MI') ='10:30'





select to_number('123') from dual;
select to_number('123.45','999.00') from dual;
select to_number('1.234','9D999') from dual;

select to_number('$17 218,00','L999G999D00',' NLS_NUMERIC_CHARACTERS='', ''') from dual;
select to_date('08-MAR-1991') from dual;
select to_date('08-03-91','DD-MM-YY') from dual;
select to_date('08-03-91','DD-MON-YY') from dual;


 select min(sal) from emp where sal>(select min(sal) from emp);


************** 2ND LOWEST SALARY*****************

select * from emp where sal=(
 select max(sal) from (select * from (select sal from emp order by sal) where   rownum <=2));

**************************************************************************************************

 ***************** 2ND HIGHEST SALARY&***********************

    select *from emp where sal=(select min(sal) from(select *from(select sal from emp order by sal desc) where rownum<=2))

***************************************************************************************

select min(sal),max(sal) from emp where sal<(select max(sal) from emp) and 
                                        sal > (select min(sal) from emp)
                                        
                                        
                                        
SELECT Sal,Ename
FROM
  (
   SELECT Sal,Ename,ROW_NUMBER() OVER(ORDER BY Sal) As RowNum
   FROM EMP
   ) As A
WHERE A.RowNum IN (2,3)                                        

select *from user_tables 

select count(empno) from user_tab_columns where table name='emp'
SELECT DNAME, DEPTNO FROM DEPT WHERE EXISTS (SELECT * FROM EMP WHERE DEPT.DEPTNO = EMP.DEPTNO) 

select * from emp where rownum < 6 order by sal asc

select *from num;

select ename from emp where to_char(hiredate,'fmMONTH')='DECEMBER'

-----------------------------------------------------------------------------



4.select *from emp order by deptno asc,job desc 

5.select distinct job from emp order by job desc

6.select empno from emp where empno in(select mgr from emp)

7.select *from emp where hiredate<('01-jan-1981');

8.select empno,ename,sal,sal*12 "annualsal" from emp order by sal*12 asc

 9.select empno,ename,job,hiredate,round(months_between(sysdate,hiredate)) "exp" from emp where empno in(select mgr from emp)

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/30) "months of exp" from emp 

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/365) "year of exp" from emp where empno in(select mgr from emp)

    select empno,ename,job,hiredate,round(to_char(sysdate-hiredate)/12) "days of exp" from emp where empno in(select mgr from emp)

**********************************************************************************************************************************************

                                        DUMMY TABLE JOINS

select *from num
select *from num

alter table num add (loc varchar2(20),sal number(5))


alter table num modify sal varchar2(10desc num
desc num

insert into num values(15,'18-jun-2010','sruthi','bang','t6000',7000)

alter table num modify sal number(5)

select sal from num


create table hike(id number(3),sal number(5))

alter table hike modify name varchar2(20)

select *from num

desc hike
update num set sal='b5000' where no=12

select n.name,h.sal,n.sal from num n,hike h where n.sal=h.sal

insert into num values(13,'shan')
select n.sal,h.name from num n inner join hike h  on(h.sal=n.sal)

select n.sal,s.salary from num n full join num s on(n.sal=to_char(s.salary)) 

select n.salary,h.sal,h.name  from num n left join hike h on(n.salary=h.sal)

select n.salary,h.sal,h.name  from num n right join hike h on(n.salary=h.sal)

select n.salary,h.sal,h.name  from num n full join hike h on(n.salary=h.sal)

select *from num n cross join hike



select *from num
select *from hike

desc hike
alter table num add salary number(5)
commit

*******************************************************************************************************************************************************

select *from tab;

select *from employees
select *from departments
select *from locations

select e.first_name,e.last_name,e.department_id,d.department_name from employees e inner join departments d on(e.department_id=d.department_id)

select e.first_name,e.last_name,e.department_id,l.city,l.state_province,l.location_id
from employees e inner join departments d on(e.department_id=d.department_id) inner join locations l on(d.location_id=l.location_id)


select e.first_name,e.last_name,e.salary,j.job_id 
from employees e inner join jobs j on e.salary between j.min_salary and j.max_salary


SELECT E.first_name, E.last_name, E.salary, J.grade_level
 FROM employees E 
   JOIN job_grades J
     ON E.salary BETWEEN J.lowest_sal AND J.highest_sal;

select e.first_name,e.last_name,d.department_id,d.department_name from employees e inner join departments d 
on(e.department_id=d.department_id) where e.department_id in(40,80)


select l.city,l.state_province,d.department_id,e.first_name,e.last_name from employees e inner join departments d
on(e.department_id=d.department_id) join locations l using(location_id) where e.first_name like'%l%'


select e.first_name,e.last_name,d.department_id,d.department_name from employees e right join departments d on(e.department_id=d.department_id)

select e.first_name,e.last_name,e.salary,s.salary 
from employees e join employees s on(e.salary < s.salary) and s.employee_id=182

commit

select e.first_name from employees e natural join departments 


desc country
create table country(cname varchar2(10),gender varchar2(2))
                                                             
insert into country values('&cname','&gender')


select cname,sum(decode(gender,'m',1,0)) male,
            sum(decode(gender,'f',1,0))female,
            sum(decode(gender,'m',1,'f',1)) total from country group by cname

select *from country


select * from emp where sal<2000;

select d.dname from emp e,dept d where d.deptno not in(e.deptno)

select dname from emp,dept where emp.deptno not in(emp.deptno)

SELECT E.ENAME,E.SAL FROM EMP ,EMP E WHERE EMP.EMPNO=E.MGR

        AND EMP.SAL<E.SAL;

SELECT 
  *
FROM
  Emp e
WHERE
  TO_NUMBER(TO_CHAR(e.hiredate, 'DD')) <= 15
  
  
  
  select ename,sal from emp where sal>(select max(sal) from emp where deptno in(select deptno from dept where dname='SALES')) 
  
  select *from emp e where rowid =(select max(rowid) from emp b where e.empno=b.empno)
 
select *from emp where rowid <>(select max(rowid)from emp b where empno=b.empno)

select *from emp where rowid =select max(rowid) from emp

select *from emp
minus
select * from emp where rownum<=(select count(*)-&n from emp)


select min(sal)from emp where sal>(select max(sal)from emp e where emp.sal>e.sal)

Select Substr(�ORACLE�,Level,1) From Dual
Connect By Level<= Length(�ORACLE�);




select level from dual connect by prior level<100



select ename,sal, case when sal>1500 then 'Just salary'
                  when sal=1500 then 'On taget'
                  when sal< 1500 then 'Below 1500' end as salary from emp 




select trunc(add_months(sysdate,-1)+19) 'mon' from dual



commit


select *from country


select female.cname,female.female,male.male from 
(select cname,sum(case when gender='f' then 1 end) as female
              sum(case when gender='m' then 1 end) as male
    from country group by cname)

            
(select cname,sum(case when gender='m' then 1 end) as male from country group by cname) male where female.cname=male.cname

select * from emp
where (case when to_char(hiredate,'mon') = to_char(sysdate,'mon') then 'current' 
           when to_char(hiredate,'mon') = to_char(add_months(sysdate,-1),'mon') then 'previous'
           end) = 'previous'  
    
    
select  level, max(sal)
from   emp
where   level=2
connect  by
prior   sal>sal
group  by  level




select 
trunc(last_day('1-aug-18') - (
case 
  when to_char(last_day('1-aug-18'),'D') >= 6 then 
    to_char(last_day('1-aug-18'),'D')  - 6 
  else to_char(last_day('1-aug-18'),'D') + 1
end
))='&year' as last_friday
from dual








select 
trunc(last_day('&date') - 
case 
  when to_char(last_day('&date'),'D') >= 6 then 
    to_char(last_day('&date'),'D')  - 6 
  else to_char(last_day('&date'),'D') + 1
end
) as last_friday
from dual




select 
trunc(last_day(sysdate) - 
case 
  when to_char(last_day(sysdate),'D') >= 6 then 
    to_char(last_day(sysdate),'D')  - 6 
  else to_char(last_day(sysdate),'D') + 1
end
) as last_friday
from dual


select to_char(last_day(sysdate),'d')>=6 from dual;


SELECT NEXT_DAY(
         LAST_DAY( SYSDATE ) - INTERVAL '7' DAY,
         'FRIDAY'
       )
FROM   DUAL;


select rtrim('xxxxumaXXXXX','X') as name from dual;

select ltrim('xxxxumaXXXXX','X') as name from dual;

select ltrim('xxxxumaXXXXX','x') as name from dual;

select trim('x' from 'xxxxumaxxx') as name from dual;

select trim('    uma    ') as name from dual;

select trim('x' from 'xyxyxyumaxyxyxy') as name from dual;

select trim('x' from 'xxxxumayyyy') as name from dual;

select trim('y' from 'xxxxumayyyy') as name from dual;

select trim('x' from 'xxxxumaxxxx') as name from dual;

select trim('111uma111') from dual;


select ename,(case when to_char(hiredate,'dd')<=15 then to_char(hiredate,'month')
                     when to_char(hiredate,'dd')>15 then to_char(add_months(hiredate,1),'month') end) paymonth from emp
                     
                  
                  
select *from excel

update excel set order_date='11-dec-1991' where sales=1

insert into emp select *from s1                  
                     
                     

select * from excel
where (case when to_char(order_date,'dd-mon-yy') between  trunc(add_months(order_date,-1),'month')+19 and 
     trunc(add_months(order_date,0),'month')+20 then 'current'
            
    when to_char(order_date,'dd-mon-yy') between  trunc(add_months(order_date,-2),'month')+19  and
            trunc(add_months(order_date,-1),'month')+20 then 'previous' end)='&enter'
           
           
select * from excel where (case when to_char(order_date,'dd-mon-yy') between
trunc(add_months(order_date,-1),'month')+19 and trunc(add_months(order_date,0),'month')+20 then 'current'
 when to_char(order_date,'dd-mon-yy') between trunc(add_months(order_date,-2),'month')+19 and trunc(add_months(order_date,-1),'month')+20 then 'previous' end)='&enter'
           
           
           
           
select trunc(sysdate)from dual;
      
          
           
         
           ******&************&&&&************ EVERY MONTH LAST FRIDAY*********&&&*************&******

select to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1)-7),'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

            last week
            
select 'Last '||to_char(next_day(trunc(sysdate - 7 , 'D'),'MON') + lvl-1, 'Day')||' : '||
to_char(next_day(trunc(sysdate - 7 , 'D'),'MON') + lvl-1)
from (select level lvl from dual connect by level <= 5)



select to_char(next_day(last_day(add_months(to_date(:yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

select to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') lastfriday from dual 
connect by level<=12;

select last_day(sysdate) - sysdate as days_left
from dual




select lpad(' ',rownum+1,'*')||ename as employees_name from emp

select rpad(' ',rownum+1,'@')||ename as employees_name from emp
select rpad(' ',rownum,'*')||ename from emp
select rpad(ename,rownum+4,'*') from emp

select ename||rpad(' ',rownum+2,'@')as employees_name from emp

select replace('she is very beautiful','ful','ma') from dual


select substr(ename,1,3) from emp;

select substr(ename,-3) from emp
select substr('umadevi',3,4) from dual

select instr('umarama','a',1,2) from dual
select instr('umarama','a',1,1) from dual where instr('umarama','a',1,1)>1


Write a query that displays the employee�s last names with the first letter capitalized and all other letters lowercase, 
and the length of the names, for all employees whose name starts with J, A, or M. Give each column an appropriate label. 
Sort the results by the employees� last names.

  select length(ename) "length",initcap(ename) "name" from emp where ename like 'J%' or ename like'A%' or ename like'M%' 
  
  select first_name as name,round((sysdate-hire_date)/365) as exp_of_years from employees
  
 select first_name as name,round(months_between(sysdate,hire_date)/12) as exp from employees
 
  select *from employees
  
  select add_months(sysdate,3) from dual

For each employee, display the employee�s last name, and calculate the number of months between today and the date the employee was hired. 
Label the column MONTHS_WORKED. Order your results by the number of months employed. Round the number of months up to the closest whole number.


select last_name,round(months_between(sysdate,hire_date)) "months_worked" from employees 


select max(salary) from employees where salary <(select max(salary) from employees)

select max(salary) from employees where salary <(select max(salary) from employees where salary <(select max(salary) from employees))


select distinct salary from employees
select max(salary) from employees

select round(avg(salary)) from employees where department_id=90

select department_id,max(salary) from employees group by department_id

select department_id,sum(salary) from employees group by department_id order by 1


For each employee, display the employee number, last_name, salary, and salary increased by 15% and expressed as a whole number. Label the column New Salary. 
Place your SQL statement in a text file named lab3_2.sql.

select employee_id,last_name,salary,round((salary*0.15)+salary) "new salary" from employees
select (salary*0.15)+salary from employees 

Select Employee_id,Last_name, Salary,Round(( Salary*(15/100)+salary)) as "New Salary" From 
Employees;


Modify your query lab3_2.sql to add a column that subtracts the old salary from the new salary. 
    Label the column Increase. Save the contents of the file as lab3_4.sql. Run the revised query. 

select Round(( Salary*(15/100)+salary)) - Salary as salary from employees


Write a query that produces the following for each employee: <employee last name> earns <salary> monthly but wants <3 times salary>. 
Label the column Dream Salaries.



select last_name||'earns'||' '||salary||' '||'monthly but wants' ||' '||salary*3  "dreame salaries" from employees

Create a query to display the last name and salary for all employees. 
Format the salary to be 15 characters long, left-padded with $. Label the column SALARY. 


select last_name,lpad(salary,15,'$') "salary" from employees 


Display each employee�s last name, hire date, and salary review date, which is the first Monday after six months of service. Label the column REVIEW. 
Format the dates to appear in the format similar to �Monday, the Thirty-First of July, 2000.�


select last_name,hire_date,salary,to_char(next_day(add_months(hire_date,6),'monday'),'day, "the" ddsp "of" month, yyyy') "review" from employees


SELECT last_name,hire_date,TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date, 6), 'Monday'),'DAY,"THE" DDSP "OF" MONTH YYYY') "REVIEW"
FROM employees;

select  to_char(next_day(last_day(add_months(to_date(&yr||'01','yyyymm'),level-1))-7,'fri'),'yyyy-mm-dd dy') 
last_friday from emp connect by level<=12


select concat(ename) from emp
select ename

SELECT deptno, LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) AS employees
FROM   emp
group by deptno

select listagg(ename,'*') within group(order by ename) from emp;

select listagg(deptno,',') within group (order by deptno) from emp

select listagg(job,',') within group (order by deptno) from emp



Select length('she is a beautiful') - length(replace('she is a beautiful', ' ', '')) + 1 NumbofWords
from dual


select length('sachin is my favorate cricketer')-length(replace('sachin is my favorate cricketer',' ',''))+1 num_of_words from dual


select length('aravinda sametha is the famous film ntr is the actor')-
length(replace('aravinda sametha is the famous film ntr is the actor',' ',''))+1 no_of_words from dual 



select length('she is a beautiful') from dual

select reverse_words('rafi shaik') from dual;

select listagg(ename,',') within group(order by ename desc) from emp 

select listagg(deptno,'*') within group(order by deptno) from emp

select listagg(job,'@') within group(order by job) from emp
select listagg('ename',',') within group(order by ename desc)


select listagg(letter) within group(order by rn)
from 
 (SELECT rownum rn, SUBSTR ('hello world', rownum*-1, 1) letter 
 FROM   dual 
 CONNECT BY rownum <= length('hello world'));


select substr('shaik rafi',instr('shaik rafi',' ',1,1)+1)||' '||substr('shaik rafi',1,5) from dual;
 
select substr('shaik rafi',instr('shaik rafi',' ',1,1)+1)||' '|| substr('shaik rafi',1,instr('shaik rafi',' ',1,1)-1) from dual


select substr('shaik rafi',1,instr('shaik rafi',' ',1,1)-1) from dual

select  distinct (case when sal >3000 then sal end ) from emp
select sal from emp where sal>3000



select b.* (select emp a,emp b
                    start with job='MANAGER' connect by prior a.empno=b.mgr order by ename) from emp;
    



238.select max(sal) from emp e where e.sal<(select e1.sal from emp e1 where e1.empno=e.mgr) 


select * from emp where sal in
 (select max(sal) from emp where mgr in
 (select empno from emp where ename = 'KING')); 


List the highest paid emp of Chicago joined before the most recently hired emp
of grade 2.


select *from emp where sal=select max(sal) from emp e,dept d where e.deptno=d.deptno and d.loc='CHICAGO' and e.hiredate <
(select e.hiredate,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal  and s.grade=2)


select *from (select *from emp where job='MANAGER'
             union all
             select *from emp where job='CLERK')


select *from ((select *from emp where job='MANAGER') union all (select *from emp where job='CLERK')) WHERE JOB='&ENTER'


select *from ((select *from emp where deptno=10)union all (select *from emp where deptno=30)) where deptno='&enter'


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&  practice queries  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


 214..select d.dname,count(*) from emp e,dept d where e.deptno=d.deptno group by dname;

 select *from newemp

213. select dname,sum(sal) "total_salary" from emp e ,dept d where e.deptno=d.deptno group by dname


212..select e.ename "emp_name",m.ename "manager_name"  from emp e,emp m where m.empno=e.mgr

211..select e.ename,d.dname from emp e right join dept d on(e.deptno=d.deptno)

210..select e.empno,e.ename,d.loc from emp e join dept d on(e.deptno=d.deptno)

209..select e.empno,d.dname,e.ename from emp e join dept d on e.deptno=d.deptno

208..update emp set comm = comm*10/100 where comm is not null

207..update emp set comm=100 where comm is null

select *from emp


206..delete from emp where (sysdate-hiredate)/365>2

205..create table newemp as select e.empno,e.ename,d.dname from emp e,dept d where e.deptno=d.deptno

202..alter table newemp add deptno number(2)

select *from newemp

203..alter table newemp add constraint foreign key(deptno) references dept(deptno)

201..alter table emp add constraint foreign key(mgr) references dept(deptno)

200..alter table emp add mgr number(10)

199..alter table emp enable constraint emp_sal_chk

select *from emp

196..alter table emp drop column salary 

195..alter table emp modify ename varchar2(30)
desc emp

194..alter table emp add primary key(empno)

193..alter table emp1 add ename varchar2(20)

192..create table emp(empno number(4))

191..select empno,sal,sal*15/100 "pf" from emp

190..select ename from emp order by ename

188..select hiredate from emp where deptno in(select deptno from emp)

select substr(ename,1,1)||' '||ename from emp

commit



select hire_date,first_name,last_name from employees where to_char(hire_date,'yyyy')=2001
select *from employees

select initcap(first_name),initcap(last_name) from employees

select job_title,substr(job_title,instr(job_title,' ')-1)



SELECT SYSDATE,'hello', student_id, COUNT(*)
FROM enrollment
GROUP BY student_id

select *from  (select e.*,'abc' a from emp e where job='MANAGER'
            union all
            select e.*,'xyz' a from emp e where sal>3000) where a='&enter'


---Display the length of first name for employees where last name contain character �b� after 3rd position.

select length(first_name),last_name from employees where last_name like'__b%'
SELECT FIRST_NAME, LAST_NAME FROM EMPLOYEES WHERE INSTR(LAST_NAME,'B') > 3

select first_name,last_name from employees where instr(last_name,'b')>3

*********Display first name in upper case and email address in lower case for employees where the first name and email address are same irrespective of the case.

select upper(first_name),lower(email) from employees where upper(first_name)=upper(email)


********Display employees who joined in the current year.

select first_name,hire_date from employees where to_char(hire_date,'yyyy')=to_char(hire_date,'yyyy');

*******Display the number of days between system date and 1st January 2011.
select  round(sysdate-to_date('01-jan-2011')) from employees

******Display manager ID and number of employees managed by the manager.
select manager_id,count(*) from employees group by manager_id

********Display employee ID and the date on which he ended his previous job.
select employee_id,max(end_date) from job_history 


create table quarter(name varchar2(10),h_date date,sal number(10));
desc quarter
commit


select 3 from dual
intersect 
select 3 from dual;

select 3 from dual
union
select 3 from dual

select *from emp where rowid<5
select *from emp where rownum<=5

SELECT sysdate, systimestamp FROM dual;

select e.*, rownum from emp e order by rownum desc



select * from 
(select e.*,rownum rn from
(select * from emp  order by sal desc) e)
where rn=5;

select *from (select e.*,rownum rn from(select * from emp order by sal desc) e) where rn=6;

select max(sal), min(sal) from emp
where sal < (select max(sal) from emp)
and sal > (select min(sal) from emp);

select max(sal),min(sal) from emp
where sal<(select max(sal) from emp)
and 
sal > (select min(sal) from emp)


select *from emp where sal=(select min(sal) from(select *from (select sal from emp order by sal desc) where rownum<=2))

select ename name, connect_by_root(ename) boss 
     from emp 
     start with empno = 7839 
     connect by prior empno = mgr;

select replace('independence','e','mama') from dual

select translate('beer bucket','beer','milk') from dual
select replace('beer bucket','beer','milk') from dual


select *from tab
select *from customers
commit



SELECT *
FROM section
WHERE start_date_time BETWEEN
TO_DATE(&#39;31-DEC-2200&#39;,&#39;DD-MON YYYY&#39;)
AND TO_DATE(&#39;01/01/1900&#39;,&#39;MM/DD/YYYY&#39;)

select replace('s h a i k',' ','') from dual

select e.ename,d.deptno,sum(sal) 
from emp e,dept d
where e.deptno=d.deptno
group by e.ename,d.deptno
having sum(sal)>1200
order by d.deptno



select rtrim('Suresh*****','*') from dual


select lpad(' ',10-level,' ')|| lpad ('*', level, '*') from dual connect by level<=10
union all 
select lpad(' ',level,' ')|| lpad ('*', 10-level, '*') from dual connect by level<=9;



select lpad(' ',10-level,' ')||lpad('*',level-1,'*') 
||rpad('*',level,'*') from dual connect by level<=10




select ename, rownum from emp where (rowid,0) in (select rowid,mod(rownum,2) from emp )

select ename,rownum from emp where (rowid,1) in(select rowid,mod(rownum,2) from emp);


select * from emp
minus
select * from emp where rownum <= (select count(*) - &n from emp);

select ename, 12*(sal+nvl(comm,0)) as "annual Sal" from emp

select *from emp
minus
select *from emp where rownum<=(select count(*)-&n from emp)

select 12*sal+nvl(comm,0) as annual from emp

select distinct sal from emp e2 where &n = (select count(distinct sal) from emp e1 where e2.sal <= e1.sal);

 

select distinct sal from emp a where &n =  (select count(distinct sal) from emp b where a.sal <= b.sal);

select deptno,count(deptno)from emp group by deptno order by deptno

select * from emp  where sal> any(select sal from emp where sal<3000);

select *from emp 
minus
select *from emp e

SELECT  deptno, sum(sal) As totalsal
FROM emp
GROUP BY deptno
HAVING COUNT(empno) > 2

select deptno,sum(sal) from emp group by deptno having sum(sal)>2


select hiredate,to_char(add_months(sysdate,hiredate)/12) from emp

select round(to_char(sysdate-hiredate)/365) from emp 

select  distinct deptno from emp where deptno in(select deptno from dept where loc='DALLAS')

SELECT SUBSTR(ENAME,1,1),ENAME FROM EMP;


select decode(2,1,1
                2,1,3) from dual
                
                
                
    select cname, sum(  decode(gender,'m',1,0)) male,
               sum(  decode(gender,'f',1,0)) female,
               sum( decode(gender,'m',1,'f',1) ) total from country
               group by cname
               
               
select f.cname,f.female,m.male from  
    (select cname,sum(case when gender='f' then 1 end) as female from country) f 
    (select canem,sum(case when gender='m' then 1 end) as male from country) m
              where f.cname=m.cname    group by f.cname     
               
               
               select * from emp where rowid in (select decode(mod(rownum,2),0,rowid, null) from emp);
               
               select *from emp where rowid in(select decode(mod(rounum,2),0,rowid,null) from emp
               
               
               select ename,rownum from emp where (rowid,1) in(select rowid,mod(rownum,2) from emp)
               select rownum,ename from emp where (rowid,0) in(select rowid,mod(rownum,2) from emp)
               
               select lpad(' ',rownum+1,'*') || ename from emp
               
  create table departments(deptno number(10),gender varchar2(10))             
               
    select *from departments
    
     select male.deptno,male.male,female.female,total.total from
(select deptno ,sum(case when lower(gender)='male' then 1 else 0 end) male from  departments group by deptno) male,
(select deptno ,sum(case when lower(gender)='female' then 1 else  0 end) female from  departments group by deptno) female,
(select deptno ,sum(case when lower(gender)='male'then 1 when lower(gender)='female' then 1 end) total from  departments group by deptno) total
where male.deptno=female.deptno
and female.deptno=total.deptno          
        
             

commit

>>>>>>>>>>>>>>>>>>>>VIEW>>>>>>>>>>>>>>>

create view v1 as select *from emp;

select *from v1

create v2 as select e.first_name,e.last_name,e.phone_number,e.department_name,d.department_id
                    from employees e,departments d 
                    where e.department_id=d.department_id and d.department_name='Accounting'

select *from tab
select *from departments

create view v2 as select e.empno,e.sal,e.deptno,d.dname,d.loc 
             from emp e,dept d
              where e.deptno=d.deptno and d.loc='DALLAS';               

select *from emp

alter v2 set  e.ename='uma' where e.empno=7369  


rollback

update v2 set ename='uma' 

create or replace view v1
    as
    select a.ename, b.ename mgr_name
      from emp a, emp b
     where a.mgr = b.empno
      WITH CHECK OPTION
      
      
  CREATE VIEW
dept_sum_vu

(name, minsal, maxsal, avgsal)

AS SELECT
d.department_name, MIN(e.salary),

MAX(e.salary),round(AVG(e.salary))

FROM employees e, departments d

WHERE e.department_id = d.department_id

GROUP BY d.department_name;    

select *from dept_sum_vu;

select *from employees
               
create view count_view
(name,id,phone,doj,dname)
as select e.first_name,count(e.employee_id),e.phone_number,e.hire_date,d.department_name)
from employees e,departments d
where e.department_id=d.department_id
group by d.department_name,e.first_name,e.phone,e.hire_date;


create or replace view count_view as
select e.first_name,count(e.employee_id)"count_id",d.department_name
from employees e,departments d
where e.department_id=d.department_id
group by e.first_name,e.employee_id,d.department_name
having count(e.employee_id)>=1

select *from count_view


select 'small' "name",'0' "lower_bound",'1000' "upper_bound" from dual
union
select 'medium' "name",'1001' "lower_bound",'2000' "upper_bound" from dual
union
select 'large' "name",'2001' "lower_bound",'3000' "upper_bound"  from dual


create or replace view v1 as select *from emp;
insert into v1(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(1001,'UMA DEVI','MANAGER',1010,'10-sep-91',1000,null,10)
select *from v1

create or replace view emp_details as select deptno,count(*) "no_of_emp",min(sal) "minimum_sal",max(sal)
 "maximum_sal",avg(sal) "average_sal" ,sum(sal) "total_sal" from emp group by deptno;

update emp_details set deptno=50 where deptno=10
select * from  emp_details 


CREATE SEQUENCE sequence
[INCREMENT BY n]
[START WITH n]
[{MAXVALUE n | NOMAXVALUE}]
[{MINVALUE n | NOMINVALUE}]
[{CYCLE | NOCYCLE}]
[{CACHE n | NOCACHE}];

create sequence seq2
increment by 10
start with 10
maxvalue 100
minvalue 1
cache 20;

select seq2.currval from dual
select seq2.nextval from dual

insert into departments(department_id,department_name) values(departments.department_id_seq2.currval,'computers')

insert into dept(deptno,dname,loc)values(seq2.nextval,'computers','pune')

select *from dept
rollback
create sequence snc start with 4 minvalue 3 maxvalue 8 cycle
drop sequence se1

create or replace view empvu10
    (employee_no,employee_name,job_title) as select empno,ename,job
	 from emp where deptno=10 with read only;
     
     select *from empvu10
     
update empvu set employee_name='UMA' where deptno=10

create sequence seq1
 increment by 20


select *from((select 'small' "name",'0' "lower_bound",'1000' "upper_bound",1 a from dual)
union all
(select 'medium' "name",'1001' "lower_bound",'2000' "upper_bound", 2 a from dual)
union all
(select 'large' "name",'2001' "lower_bound",'3000' "upper_bound", 3 a  from dual)) where a=&n;

commit

create public synonym syn1 for scott.emp

select deptno,sum(sal) from emp
group by rollup(deptno);

select deptno,sum(sal),job from emp
group by rollup(deptno,job);

select deptno,sum(sal),job from emp
group by rollup(job,deptno);

select deptno,sum(sal),job from emp group by deptno rollup(job)


select *from emp
delete from emp where ename='UMA DEVI'

select ename, sal,
DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal)
from emp
--where ename = 'SMITH';



select case when grouping (deptno)=1 then 'Total'
   else cast(deptno as varchar2(20))
   end deptno, sum(sal) from emp 
    group by rollup(deptno)


set serveroutput on;
DECLARE
    a number(5) NOT NULL := 2
    name varchar2(15) := 'Branson Devs';
    ed CONSTANT varchar2(15) := 'Web Developer';
BEGIN
    dbms_output.put_line('Declared Value:');
    
    end;
   -- dbms_output.put_line(' Employee number: ' || eno || ' Employee Name: ' || ename);
    --dbms_output.put_line('Constant Declared:');
    --dbms_output.put_line(' Employee Department: ' || ed);    
END;


DECLARE
    pi CONSTANT REAL := 3.14159;
    radius REAL := 3;
    area REAL := (pi * radius**2);
BEGIN
    dbms_output.put_line(' PI: ' || pi || ' Radius: ' || radius);
    dbms_output.put_line(' Area: ' || area);    
END;



declare
 a number;
 b number;
 c number;
 begin
 a:=2;
 b:=3;
 c:=a+b;
 dbms_output.put_line('the sum of two numbers is :'|| c);
 end;
 
 commit
 
 begin
 null;
 end;
 ..............................................................................................
 
 ALL CURSOR ATTRIBUTES
 
 
 declare
cursor c1 is select ename from emp;
cursor c2 is select deptno from emp;
vename emp.ename%type;
vdeptno emp.deptno%type;
rowcount number;
begin
if not c1%isopen then
open c1;
end if;
loop
fetch c1 into vename;
exit when c1%notfound;
uma(vename);
end loop;
rowcount:=c1%rowcount;
uma('the no of employees are:'||' '||c1%rowcount);
close c1;
open c2;
fetch c2 into vdeptno;
while c2%found
loop
fetch c2 into vdeptno;
uma(vdeptno);
end loop;
close c2;
end;



commit
 
 
------------------------------------------------------------------------------------------------------------- 
 

create table salespeople(snum number,sname varchar2(15),city varchar2(15),comm number);

insert into salespeople values(1001,'Peel','London',0.12);
insert into salespeople values(1002,'Serres','San Jose',0.13);
insert into salespeople values(1004,'Motika','London',0.11);
insert into salespeople values(1007,'Rafkin','Barcelona',0.15);
insert into salespeople values(1003,'Axelrod','New York',0.1);

create table customers(cnum number,cname varchar2(15),city varchar2(15),rating number,snum number);

insert into customers values(2001,'Hoffman','London',100,1001);
insert into customers values(2002,'Giovanne','Rome',200,1003);
insert into customers values(2003,'Liu','San Jose',300,1002);
insert into customers values(2004,'Grass','Brelin',100,1002);
insert into customers values(2006,'Clemens','London',300,1007);
insert into customers values(2007,'Pereira','Rome',100,1004);

create table orders(onum number,amt number,odate date,cnum number,snum number);

insert into orders values(3001,18.69,'03-OCT-94',2008,1007);
insert into orders values(3003,767.19,'03-OCT-94',2001,1001);
insert into orders values(3002,1900.1,'03-OCT-94',2007,1004);
insert into orders values(3005,5160.45,'03-OCT-94',2003,1002);
insert into orders values(3006,1098.16,'04-OCT-94',2008,1007);
insert into orders values(3009,1713.23,'04-OCT-94',2002,1003);
insert into orders values(3007,75.75,'05-OCT-94',2004,1002);
insert into orders values(3008,4723,'05-OCT-94',2006,1001);
insert into orders values(3010,1309.05,'06-OCT-94',2004,1002);
insert into orders values(3011,9891.88,'06-OCT-94',2006,1001);

select * from orders;


select *from customers

select*from salespeople


select length('Count the number of words in this sentence')
-length(replace('Count the number of words in this sentence',' ',''))+1 "no of words" from dual

Jaya Praveen" to "Praveen Jaya"

select substr('Jaya Praveen',instr('Jaya Praveen',' ',1,1)+1)||' '||substr('Jaya Praveen',1,instr('Jaya Praveen',' ', 1,1)-1) from dual

I have string like this: "s h a i k" but i want to show it as "shaik".

select substr('s h a i k',1,instr('s h a i k',' ','')+1) from dual



I have data like this 
Name
Suresh*****
Ramesh***
Rakesh****


select rtrim('Suresh','*') from dual



Name       Orderid                Result_Order
Pallavi    123456789012     1234****9012
Rafi         1234567890         1234**7890
Pavan      12345678             12345678


create table Result_Order(Name varchar2(20),orderid number(20))

insert into Result_Order values(&Name,&Orderid);


select *from Result_Order

desc Result_Order

insert into Result_Order(Name,Orderid)values('pavan',1234567890)

drop table Result_Order

select Orderid from Result_Order where Orderid like'%*%'

select rpad(Orderid,'*',
commit

select e.ename,s.grade,sum(sal),d.deptno  e.sal between s.losal and s.hisal  having sum(sal)>10000 order by e.ename

select *from emp


select sum(sal),e.ename,d.deptno from emp e,dept d
where e.deptno=d.deptno where e.ename='SMITH' and sal>2000
order by e.ename,e.sal,d.deptno


Find names and numbers of all salesperson who have more than one customer

select *from salespeople
select s.snum,s.sname,c.cnum from salespeople s,customers c where s.snum=c.snum and c.cnum>1 

select *from customers

.Produce the names and rating of all customers who have above average orders.


select avg(onum),c.cname,c.rating from customers c join orders o on(o.cnum=c.cnum)
group by c.cname,c.rating and o.onum>avg(onum)

select *from orders

All customers in San Jose, who have rating more than 200.

select cname,rating from customers where cname='san jose' and rating>200

select *from customers where city is null

All orders taken on Oct 3Rd   and Oct 4th  1994.


select *from orders where odate between ('3-oct-1994') and ('4-oct-1994')

All customers excluding those with rating <= 100 unless they are located in Rome

select *from customers where city='rome'and rating not in(select rating from customers where rating<=100)

All customers serviced by peel or Motika.

select s.snum,c.snum,s.sname 
from salespeople s join customers c 
on c.snum=s.snum where s.sname in('Peel','Motika') 

select *from salespeople


All orders except those with 0 or NULL value in amt field.

select *from orders where amt is not null and amt <>0

. Largest order taken by each salesperson, datewise.

select max(odate) from orders order by odate

select s.sname,o.odate from salespeople s,orders o where s.snum=


Which day had the hightest total amount ordered.

select odate from orders where amt=(select max(sum(amt)) from orders group by odate)

select odate,amt from orders where amt=
 (select max(a) from(select sum(amt) a from orders group by odate,amt))

select max(amt) from orders


. Count the number of different non NULL city values in customers table.
select count(*) from customers where city is not null

Get the output like � For dd/mm/yy there are ___ orders.


select odate,count(*) from orders group by odate  

select count(*) from orders

All combinations of salespeople and customers who shared a city.

select s.sname,c.snum from salespeople s ,customers c where s.snum=c.snum and c.city=s.city

List each order number followed by the name of the customer who made the order.

select o.onum,c.cnum,c.cname from orders o join customers c on o.cnum=c.cnum and 


Calculate the amount of the salesperson�s commission on each order with a rating above 100.

Largest order taken by each salesperson, datewise.

select o.onum,s.snum,max(o.amt) 
from salespeople s,orders o 
where s.snum=o.snum 
group by o.onum,s.snum
order by o.odate


select rtrim(Name,'*') from dual


Find all pairs of customers having the same rating.


select cname from customers where rating=100 

select cname,city from cust where rating=(select rating from cust where  cname='Hoffman');

Count the customers with rating  above San Jose�s average.

select count(*) from customers where rating >(select avg(rating) from customers where city='San Jose')


Produce the names and rating of all customers who have above average orders

select cname,rating from customers  where cnum in(select cnum from orders


How to find Nth word in a given string? 


select substr('find the 4th word in this string',instr('find the 4th word in this string' ,' ',1,6)+1) from dual



Calculate the amount of the salesperson�s commission on each order with a rating above 100.


select o.amt,s.comm,c.rating
from salespeople s join orders o on (s.snum=o.snum) join customers c
on (o.cnum=c.cnum) and c.rating>100


selec


t cname,city from customers where rating=(select rating from customers where  cname='Hoffman');

.Display all customers located in cities where salesman serres has customer.

select cname from customers where city in(select s.city from customers c, salespeople s where c.snum=s.snum and s.sname='Serres')


select *from Result_Order
select replace(orderid,substr(instr(orderid,5,'*',456))) from dual

select sin(-45) from dual

select*from Result_Order

select rpad(substr(Orderid,1,4),round((length(Name)/2))+4,'*')||''||substr(Orderid,-4)
  from Result_Order
  
insert into Result_Order(Name,Orderid)values('pavan',1234567890)


04061606161 7 2 3 2 #


select substr('find the 4th word in this string' ,instr('find the 4th word in this string' ,' ',-1) )from dual

commit
 create table tab(name varchar2(20),orderid number(20))
insert into tab values('Pallavi',123456789012)
insert into tab values('Pavan',12345678)
select *from tab

select rpad(substr(orderid,1,4),round((length(name)/2))+4,'*')||''||substr(orderid,-4) from tab

select substr('find the 4th word in this string' ,instr('find the 4th word in this string' ,' ',-1) )from dual

select substr('collapses fields of the result set into their distinct values',
    instr('collapses fields of the result set into their distinct values',' ',-1)) from dual 
    
    
    
 Select c.cname, c1.cname,c1.rating
from customers c, customers c1
where c.rating = c1.rating and
          c.cnum != c1.cnum   
          
      
          
          SELECT *
FROM section
WHERE start_date_time BETWEEN
TO_DATE(&#39;31-DEC-2200&#39;,&#39;DD-MON YYYY&#39;)
AND TO_DATE(&#39;01/01/1900&#39;,&#39;MM/DD/YYYY&#39;)


Select 'For ' || to_char(odate,'dd/mm/yy') || ' there are '||
count(*) || ' Orders'
from orders
group by odate;

select max(amt) from (select snum from orders group by odate)



----------------------------------------------------------------------------------------------------------------------------------

 
 
 set serveroutput on
declare
cursor c1(p_job varchar2) is select * from emp where job=p_job;
i emp%rowtype;
begin
open c1('MANAGER');
dbms_output.put_line('the manager name is:');
loop
fetch c1 into i;
exit when c1%notfound;
dbms_output.put_line(i.ename);
end loop;
close c1;
open c1('ANALYST');
dbms_output.put_line('the analyst name is:');
loop
fetch c1 into i;
exit when c1%notfound;
dbms_output.put_line(i.ename);
end loop;
close c1;
end;

.............................................................

set serveroutput on
declare
cursor c is select ename,sal+(sal*0.15),deptno from emp where deptno=10;
v_ename emp.ename%type;
v_sal emp.sal%type;
v_deptno emp.deptno%type;
h number:=0;
begin
open c;
loop 
fetch c into v_ename,v_sal,v_deptno;
exit when c%notfound;
dbms_output.put_line('emp name '||v_ename||' increase sal '||v_sal||' deptno '||v_deptno);
h:=h+1;
end loop;
close c;
dbms_output.put_line('NO. of employees from dept 10 is '||h);
end;

declare
cursor c1 is select ename,sal+(sal*0.15),deptno from emp where deptno=10;
v_ename emp.ename%type;
v_sal emp.sal%type;
v_deptno emp.deptno%type;
h number:=0;
begin
open c1;
loop
fetch c1 into v_ename,v_sal,v_deptno;
exit when c1%notfound;
dbms_output.put_line(v_ename||'is increment by sal'||v_sal||'deptno'||v_deptno);
h:=h+1;
end loop;
dbms_output.put_line('the no.of employees are :'||h);
close c1;
end ;

set serveroutput on
declare
cursor c1 is select ename,deptno,sal+(sal*0.15) from emp where deptno=10;
i emp%rowtype;
h number:=0;
begin
open c1;
loop
fetch c1 into i.ename,i.deptno,i.sal;
exit when c1%notfound;
dbms_output.put_line('emp name'||i.ename||' '||'is increment by sal'||' '||i.sal||' '||'deptno'||' '||i.deptno);
h:=h+1;
end loop;
dbms_output.put_line('the no of employees are:'||h);
close c1;
end ;

declare
cursor c1 is select deptno,dname from dept;
v_deptno dept.deptno%type;
v_dname dept.dname%type;
begin
open c1;
loop
fetch c1 into v_deptno,v_dname;
exit when c1%notfound;
uma('The list of employees in department '||v_deptno||' '||v_dname||' is as follows: ');
declare
cursor c2(v_deptno number) is select *from emp where deptno=v_deptno;
i emp%rowtype;
begin
open c2(v_deptno);
loop
fetch c2 into i;
exit when c2%notfound;
uma(i.ename||' '||i.job||' '||i.sal||' '||i.deptno);
end loop;
close c2;
end;
end loop;
close c1;
end;


set serveroutput on
declare
cursor c1 is select deptno,dname from dept;
v_deptno dept.deptno%type;
v_dname dept.dname%type;
begin
open c1;
loop
fetch c1 into v_deptno,v_dname;
exit when c1%notfound;
uma('The list of employees in department '||v_deptno||' '||v_dname||' is as follows: ');
declare 
cursor c2(v_deptno number) is select * from emp where deptno=v_deptno;
empdet emp%rowtype;
begin
open c2(v_deptno);
loop 
fetch c2 into empdet;
exit when c2%notfound;
uma(empdet.ename||' '||empdet.job||' '||empdet.sal||' '||empdet.deptno);
end loop;
close c2;
end;
end loop;
close c1;
end;


declare
cursor c1 is select deptno,dname from dept;
v_deptno dept.deptno%type;
v_dname dept.dname%type;
begin
open c1;
loop
fetch c1 into v_deptno,v_dname;
exit when c1%notfound;
uma('the employees in department'||' '||v_deptno||' '||v_dname||' '||'is  as follows');
    declare
    cursor c2(v_deptno number) is select * from emp where deptno=v_deptno;
    empdet emp%rowtype;
    begin
    open c2(v_deptno);
        loop
        fetch c2 into empdet;
        exit when c2%notfound;
        uma(rpad(empdet.ename,6)||' '||rpad(empdet.job,6)||' '||rpad(empdet.sal,6)||' '||rpad(empdet.deptno,6));
        end loop;
    close c2;
    end;
end loop;
close c1;
end;

declare
esal emp.sal%type;
sgrade salgrade.grade%type;
pos varchar2(1000);
begin
select e.sal,s.grade,case when grade=1 then 'engineer'
                            when grade=2 then 'lead'
                            when grade=3 then 'sr.engineer'
                            when grade=4 then 'jr.engineer'
                            when grade=5 then 'project engineer' 
                            else 'no position' end
into esal,sgrade,pos from emp e,salgrade s where e.sal between s.losal and s.hisal and empno=7369;
uma(esal||' '||sgrade||' '||pos);
end;



set serveroutput on
declare
vempno emp.empno%type:=&eno;
vsal emp.sal%type;
vcomm emp.comm%type;
vbonus emp.sal%type;
begin
select sal,comm into vsal,vcomm from emp where empno=vempno;
if vcomm is null then
dbms_output.put_line('emp doesnot earn comm');
else 
vbonus:= vcomm *0.15;
vsal := vsal + vbonus;
dbms_output.put_line(vbonus||' bonus has been added to the salary and the current salary is: '||vsal);
end if;
end;

declare
vempno emp.empno%type:=&eno;
vsal emp.sal%type;
vcomm emp.comm%type;
vbonus emp.sal%type;
begin
select sal,comm into vsal,vcomm from emp where empno=vempno;
if vcomm is null then 
uma(' the employee hs no commission');
else
vbonus:=vcomm*0.15;
vsal:=vsal+vbonus;
uma(vbonus||' '||'the increment sal and current sal is:'||vsal);
end if;
end;

declare
fac number:=1;
n number:=&n;
begin
while n>0
loop
fac:=fac*n;
n:=n-1;
end loop;
uma(fac);
end;

declare
cursor c is select *from emp for update;
i emp%rowtype;
begin
open c;
loop
fetch c into i;
exit when c%notfound;
if i.job='ANALYST' then
update emp set sal=sal+100 where current of c;
end if;
end loop;
close c;
end;

select *from emp
rollbav

drop table emp
create table emp as select *from x where 1=1


declare
cursor c1 is select *from emp order by sal desc;
i emp%rowtype;
begin
open c1;
loop
fetch c1 into i;
uma(rpad(i.ename,6)||' '||i.sal);
exit when c1%rowcount=5;
end loop;
uma('the no of employees are:'||c1%rowcount);
close c1;
end;

declare
cursor c1 is select *from emp;
i emp%rowtype;
begin
open c1;
loop
fetch c1 into i;
exit when c1%notfound;
if mod(c1%rowcount,2)=0 then
--uma('the even records are as fallows :');
uma(i.ename||' '||i.deptno||' '||c1%rowcount);
end if;
end loop;
end;


declare
cursor c1 is select ename from emp;
cursor c2 is select deptno from emp;
v_ename emp.ename%type;
v_deptno emp.deptno%type;
rownumber  number;
begin
if not c1%isopen then
open c1;
end if;
loop
fetch c1 into v_ename;
exit when c%notfound;
uma(v_ename);
end loop;
rownumber:=c1%rowcount;
uma(c1%rowcount);
close c1;
open c2;
fetch c2 into v_deptno;
while c1%found then
fetch c2 into v_deptno;
uma(v_deptno);



declare
cursor c1 is select ename,sal from emp;
v_ename varchar2(20);
v_sal number(20);
begin
if not c1%isopen
then
open c1;
end if;
fetch c1 into v_ename,v_sal;
while c1%found
loop
fetch c1 into v_ename,v_sal;
loop
fetch c1 into v_ename,v_sal;
exit when c1%notfound;
exit when c1%rowcount>5;
dbms_output.put_line( rpad(v_ename,10,' ') || v_sal|| ' ' ||c1%rowcount|| rpad(' ',10));
end loop;
end loop;
close c1;
end;

declare
cursor c1 is select ename from emp;
cursor c2 is select deptno from emp;
vename emp.ename%type;
vdeptno emp.deptno%type;
rowcount number;
begin
if not c1%isopen then
open c1;
end if;
loop
fetch c1 into vename;
exit when c1%notfound;
uma(vename);
end loop;
rowcount:=c1%rowcount;
uma('the no of employees are:'||' '||c1%rowcount);
close c1;
open c2;
fetch c2 into vdeptno;
while c2%found
loop
fetch c2 into vdeptno;
uma(vdeptno);
end loop;
close c2;
end;

set serveroutput on
declare
cursor c1 is select deptno,dname from dept;
v_deptno dept.deptno%type;
v_dname dept.dname%type;
begin
open c1;
loop
fetch c1 into v_deptno,v_dname;
exit when c1%notfound;
dbms_output.put_line('The list of employees in department '||v_deptno||' '||v_dname||' is as follows: ');

declare 
cursor c2(v_deptno number) is select * from emp where deptno=v_deptno;
empdet emp%rowtype;
begin
open c2(v_deptno);
loop 
fetch c2 into empdet;
exit when c2%notfound;
dbms_output.put_line(empdet.ename||' '||empdet.job||' '||empdet.sal||' '||empdet.deptno);
end loop;
close c2;
end;
end loop;
close c1;
end;







declare
cursor c1 is select deptno,dname from dept;
vdeptno dept.deptno%type;
vdname dept.dname%type;
begin
open c1;
loop
fetch c1 into vdeptno,vdname;
exit when c1%notfound;
uma('the list of department employees:'||vdname||' '||vdeptno);
declare 
cursor c2(vdeptno number) is select *from emp where deptno=vdeptno;
i emp%rowtype;
begin
open c2(vdeptno);
loop
fetch c2 into i;
exit when c2%notfound;
uma(i.ename||' '||i.sal||' '||i.job);
end loop;
close c2;
end;
end loop;
close c1;
end;

commit


------------------------------------------------------------------------------------------------------------------



 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 